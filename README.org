#+TITLE: Emacs configuration file
#+AUTHOR: Jonathan David Page
#+PROPERTY: header-args:emacs-lisp :tangle init.el :noweb yes :lexical yes

* Prelude

This file organizes settings from most-to-least general. If you're
interested in basing your own configuration on mine, but don't want
all of my bells and whistles (or you want different bells and
whistles), then this is probably the section to keep. It describes a
fairly minimal Emacs setup, with as few packages as
possible.[fn:packages] In particular, it pulls in package management
and sets up some sane defaults, many of which are pulled from the
[[https://git.sr.ht/~technomancy/better-defaults][better-defaults package]].[fn:better-defaults]

#+BEGIN_SRC emacs-lisp
  ;;; init.el --- main init   -*- lexical-binding: t -*-

  ;;; Commentary:
  ;; THIS IS A GENERATED FILE; changes should be made to README.org

  ;;; Code:

  ; I guess this is useful for pre-27 Emacs, but it's mostly so that flycheck stops
  ; yelling at me.
  (require 'early-init (expand-file-name "early-init.el" user-emacs-directory))
#+END_SRC

I use lexical binding (I believe now the default in Emacs 27.1) and a
lot of byte-compilation. Now that we have =early-init.el=, we can
byte-compile the main init file, as we can use it to tell Emacs that a
newer uncompiled file should be preferred to the byte-compiled file.

#+BEGIN_SRC emacs-lisp :tangle early-init.el
  ;;; early-init.el --- early bird init   -*- lexical-binding: t; no-byte-compile: t -*-

  ;;; Commentary:
  ;; THIS IS A GENERATED FILE; changes should be made to README.org

  ;;; Code:

  (setq load-prefer-newer t)
#+END_SRC

[fn:packages] Specifically: =straight.el=, =use-package=, =no-littering= and
on macOS, =exec-path-from-shell=.

[fn:better-defaults] I originally used better-defaults directly, but
got fed up with having to peek inside it to check if a setting had
already been configured. Additionally, it sets up some things I don't
care about: =ido-mode= (I use =ivy=) and =isearch= (I use =swiper=). I include
=ivy= and =swiper= when I spin off versions of this file for people, so I
haven't bothered to set up =ido-mode= and =isearch=. Check =better-defaults=
for how to enable them.

** Package Management

Package management and configuration is based on a combination of
[[https://github.com/jwiegley/use-package][use-package]] for declarative package configuration, and [[https://github.com/raxod502/straight.el][straight.el]] for
reproducible package installation. The [[file:straight/versions/default.el][lock file]] generated by
=straight.el= is checked in alongside the configration. Between the two
of these, I can delay loading packages until they're needed, and I can
revert to older versions of packages if (when) something breaks.

Some configuration options need to be set before the bootstrap code
for =straight.el= is loaded. Specifically, we want =use-package= to
automatically tell =straight.el= about the packages we're using so that
they can be installed. The setting below prevents us from having to
use the =:straight= option in =use-package= forms (which is the
replacement for =:ensure=, which should not be used).

#+BEGIN_SRC emacs-lisp :tangle early-init.el
  (setq straight-use-package-by-default t)
#+END_SRC

Because =straight.el= is installed before we've initialized any kind of
package management, bootstrap code must be run to set it up. This is
just copy-pasted from the README. Note that installing packages
requires Git to be installed and in the path. It also requires a
network connection.

#+BEGIN_SRC emacs-lisp :tangle early-init.el
  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
#+END_SRC

Now we can ask =straight.el= to install =use-package= for us.

#+BEGIN_SRC emacs-lisp :tangle early-init.el
  (setq use-package-verbose t)
  (straight-use-package 'use-package)
  (require 'bind-key)  ; needed for byte-compilation
#+END_SRC

** No Littering

Emacs and its packages tend to scatter files around madly. The
[[https://github.com/emacscollective/no-littering][no-littering]] package helps tidy that up, and replaces a number of
paths that I previously configured manually.

#+BEGIN_SRC emacs-lisp
  (use-package no-littering)
#+END_SRC

I used to have this in my =early-init.el=, but it turns out that several
settings need to wait until we get to the main init phase, so here it
is, right at the top.

** Init File in Org-Mode

To help keep things organized without creating an explosion of little
files, the user configuration all lives in this =org-mode= file,
=README.org=. On buffer save, it gets tangled into regular elisp files,
=init.el=. If for some reason the auto-tangle doesn't work, it can be
trigged manually with =org-babel-tangle= (=C-c C-v t=).

#+BEGIN_SRC emacs-lisp
  (defun my/tangle-init ()
    "Tangle the buffer if it's README.org in the user dir."
    (when (equal (buffer-file-name)
                 (expand-file-name "README.org" user-emacs-directory))
      ;; Avoid running hooks when tangling
      (let ((prog-mode-hook nil)
            (org-confirm-babel-evaluate nil))
        (org-babel-tangle)
        (byte-compile-file (expand-file-name "init.el" user-emacs-directory)))))

  (add-hook 'after-save-hook 'my/tangle-init)
#+END_SRC

Since =init.el= gets overwritten constantly, leting Emacs add
customizations to it isn't very useful. It should put them in a
separate file instead. I personally don't use the custom interface, or
if I do, I eventually incorporate the changes into this file, but I
sometimes spin off versions of my config to help other people get
started, and it's good for them to be able to use the customization
interface.

#+BEGIN_SRC emacs-lisp
  (setq custom-file (no-littering-expand-etc-file-name "custom.el"))
  (add-hook 'after-init-hook #'(lambda ()
                                 (message "loading %s" custom-file)
                                 (load custom-file t)))
#+END_SRC

** Platform-Specific Settings

I've elected to group platform-specific settings with related
platform-independant settings, rather than in one place. To assist
with both writing them and locating them, I define some constants to
test against and grep for.

*** GNU-Like Systems (incl. Windows)

Some Emacs features need to be configured differently depending on
whether or not the core utils installed support the options provided
by the GNU versions of those tools. Personally, I don't install the
GNU versions of tools on macOS and FreeBSD, since it can break other
things, but I do install them on Windows. If your systems look
different, you will need to change this.

#+BEGIN_SRC emacs-lisp :tangle early-init.el
  (defconst *my/is-winnt*
    (or (string= "windows-nt" system-type)
        (string= "cygwin" system-type))
    "Non-nil if Emacs is running under Windows.")

  (defconst *my/is-gnu-like*
    (or *my/is-winnt*  ; usually means GoW/Cygwin/MSYS2
        (string-prefix-p "gnu" (symbol-name system-type)))
    "Non-nil if we expect GNU-like coreutils.")
#+END_SRC

*** macOS

While I've deployed versions of this config file to macOS, I don't
test it often, so some changes may be required.

#+BEGIN_SRC emacs-lisp :tangle early-init.el
  (defconst *my/is-macos*
    (memq window-system '(mac ns))
    "Non-nil if Emacs is running under macOS.")
#+END_SRC

If you configure environment variables in your shell's config file,
GUI applications will miss out on them. The [[https://github.com/purcell/exec-path-from-shell][exec-path-from-shell]]
package fixes this by launching a shell and querying it.

#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
    :if *my/is-macos*
    :config
    (exec-path-from-shell-initialize))
#+END_SRC

** Safety & Backups

By default, Emacs keeps the previous version of each file around in a
backup file, which is placed alongside the backed-up file. This makes
them easy to find, but causes a lot of clutter. A better option is to
store them all in one directory; this also makes it practical to keep
multiple versions. (See [[No Littering]])

#+BEGIN_SRC emacs-lisp
  (setq backup-by-copying t    ; don't clobber symlinks
        version-control t      ; numbered backups
        delete-old-versions t  ; manage excess backups
        kept-old-versions 6
        kept-new-versions 9)
#+END_SRC

Delete files by moving them to the system trash, rather than unlinking
them from the filesystem.

#+BEGIN_SRC emacs-lisp
  (setq delete-by-moving-to-trash t)

  (when *my/is-macos*
    (defun system-move-file-to-trash (file)
      "Use \"trash\" to move FILE to the system trash.
       When using Homebrew, install it using \"brew install trash\"."
      (call-process (executable-find "trash")
                    nil 0 nil
                    file)))
#+END_SRC

** History & Recent File Persistence

Emacs can save your minibuffer history and several other histories to
a file for you using the built-in [[https://www.emacswiki.org/emacs/SaveHist][savehist-mode]]. This allows them to
persist across sessions.

#+BEGIN_SRC emacs-lisp
  (use-package savehist
    :custom
    (savehist-save-minibuffer-history t)
    (history-length 10000)  ; set to t for infinite history
    (history-delete-duplicates t)
    (savehist-additional-variables '(kill-ring
                                     search-ring
                                     regexp-search-ring
                                     shell-command-history))
    :config
    (savehist-mode +1))
#+END_SRC

Emacs can also save a list of your recently-edited files using the
built-in [[https://www.emacswiki.org/emacs/RecentFiles][recentf-mode]] There are better tools for jumping between large
numbers of files, which I set up later, but this is good to have
around, especially for loose files.

#+BEGIN_SRC emacs-lisp
  (use-package recentf
    :custom
    (recentf-max-saved-items 100)
    :config
    (recentf-mode +1))
#+END_SRC

Last but not least, the built-in [[https://www.emacswiki.org/emacs/SavePlace][save-place-mode]] will remember where
the cursor was in a file when it was closed, and put the cursor back
there when it's reopened.

#+BEGIN_SRC emacs-lisp
  (use-package saveplace
    :config
    (save-place-mode +1))
#+END_SRC

** Buffer Management

By default, if two buffers point to different files with the same
filename, Emacs numbers them. The built-in [[https://www.emacswiki.org/emacs/uniquify][uniquify]] library changes
this behaviour to use the folder name instead.

#+BEGIN_SRC emacs-lisp
  (use-package uniquify
    :straight nil
    :custom
    (uniquify-buffer-name-style 'forward))
#+END_SRC

The built-in [[https://www.emacswiki.org/emacs/IbufferMode][ibuffer-mode]] provides an improved interface for buffer
management. All that's needed to set it up is to bind it to a key.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x C-b") 'ibuffer)
#+END_SRC

I want my buffers to be set up for UTF-8 with UNIX line endings unless
otherwise specified, even on Windows.

#+BEGIN_SRC emacs-lisp
  (set-language-environment "UTF-8")
  (setq-default buffer-file-coding-system 'utf-8-unix)
#+END_SRC

When the file a buffer is monitoring is changed outside Emacs, it's
helpful to have the buffer updated to match the file if the buffer
hasn't been modified. The built-in [[https://www.emacswiki.org/emacs/AutoRevertMode][auto-revert-mode]] provides this
feature.

#+BEGIN_SRC emacs-lisp
  (global-auto-revert-mode +1)
#+END_SRC

** Sparse GUI

By default, Emacs provides a set of conventional UI elements. I like
to turn most of these off, since there are alternatives that I'm more
used to and take up less screen space. In spun-off configurations, I
turn all of these back on. These also go into the =early-init.el= file,
so that Emacs doesn't spend time loading those elements and then
unloading them again.

I prefer Emacs to go straight to an empty =*scratch*= when it loads,
with no startup message.

#+BEGIN_SRC emacs-lisp :tangle early-init.el
  (setq inhibit-startup-message t)
  (setq initial-scratch-message nil)
#+END_SRC

The menu bar can be useful for rarely-used commands to which one
doesn't remember the keybindings. I generally prefer to use =M-x= to
search for them by name, rather than hunting through the menu bar.
However, on macOS, a menu bar gets drawn anyway, so we might as well
leave it enabled.

#+BEGIN_SRC emacs-lisp :tangle early-init.el
  (unless *my/is-macos*
    (menu-bar-mode -1))
#+END_SRC

The toolbar is geared towards frequently-used commands, and outlives
its usefulness once you learn the keybindings.

#+BEGIN_SRC emacs-lisp :tangle early-init.el
  (when (fboundp 'tool-bar-mode)
    (tool-bar-mode -1))
#+END_SRC

Word-wrapping is nicer than horizontal scrollbars, and there are
smaller vertical position indicators available than vertical
scrollbars.

#+BEGIN_SRC emacs-lisp :tangle early-init.el
  (when (fboundp 'scroll-bar-mode)
    (scroll-bar-mode -1))
  (when (fboundp 'horizontal-scroll-bar-mode)
    (horizontal-scroll-bar-mode -1))
#+END_SRC

If you like line numbers, change this to =+1= instead of =-1=.

#+BEGIN_SRC emacs-lisp
  (global-display-line-numbers-mode -1)
#+END_SRC

I find a blinking cursor distracting, but many people are used to it
or need it in order to locate the cursor. Again, change to =+1= from =-1=
to re-enable the cursor.

#+BEGIN_SRC emacs-lisp
  (blink-cursor-mode -1)
#+END_SRC

See [[https://www.emacswiki.org/emacs/AlarmBell][Alarm Bell]] on the Emacs Wiki for options related to the bell. I
currently prefer a simple flashing bell.

#+BEGIN_SRC emacs-lisp
  (setq visible-bell t)
#+END_SRC

Emacs often asks yes-or-no questions, but some of the prompts don't
accept bare y/n answers. Replacing the yes-or-no prompt with the
y-or-n prompt fixes that if you want less typing in your life.

#+BEGIN_SRC emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Core Text Editing

Conventional text editors allow you to replace text by selecting it
and beginning to type. Emacs can do that too with the built-in
[[https://www.emacswiki.org/emacs/DeleteSelectionMode][delete-selection-mode]].

#+BEGIN_SRC emacs-lisp
  (delete-selection-mode +1)
#+END_SRC

When doing cut/paste (kill/yank) from inside Emacs, save the system
clipboard to the kill ring so that we can get it back later. Also,
when pasting with the mouse, insert at the point, rather than the
actual click location.

#+BEGIN_SRC emacs-lisp
  (setq save-interprogram-paste-before-kill t
        mouse-yank-at-point t)
#+END_SRC

Show the parenthesis matching the one the cursor is on.

#+BEGIN_SRC emacs-lisp
  (show-paren-mode +1)
#+END_SRC

Use spaces instead of tabs for indentation by default. This can also
be toggled per-mode or per-buffer. Also, require a final newline in
files; per POSIX, it's required, though it usually doesn't matter.
However, it /does/ matter for a few files (=crontab=), and Git doesn't
seem to be a huge fan of files without trailing newlines.

#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
  (setq require-final-newline t)
#+END_SRC

Trailing whitespace tends to be a bit of a liability, since you can't
see it easily. We would like buffers to highlight it by default, with
the exception of the minibuffer, where it doesn't matter and tends to
jank up the display from some tools.

#+BEGIN_SRC emacs-lisp
  (setq-default show-trailing-whitespace t)

  (add-hook 'minibuffer-setup-hook #'(lambda ()
                                       (setq show-trailing-whitespace nil)))
#+END_SRC

Long lines are also a bit of a liability. Many people standardise on
80, but I usually settle on 88. Notably, the [[https://github.com/psf/black][Black autoformatter]] for
Python does this as well. This setting can be changed per-mode and
per-buffer.

#+BEGIN_SRC emacs-lisp
  (setq-default fill-column 88)
  (setq-default auto-fill-function 'do-auto-fill)
#+END_SRC

Some files do have long lines in them, and I like to have those lines
word-wrapped instead of scrolling off the side of the page.

#+BEGIN_SRC emacs-lisp
  (setq-default truncate-lines nil)
  (global-visual-line-mode 1)
#+END_SRC

By default, Emacs binds =M-z= to =zap-to-char=, which deletes everything
up to and including the specified character. An alternative that does
not delete the specified character, =zap-up-to-char=, is included with
Emacs. =better-defaults= rebinds this.

#+BEGIN_SRC emacs-lisp
  (autoload 'zap-up-to-char "misc"
    "Kill up to, but not including ARGth occurrence of CHAR." t)
  (global-set-key (kbd "M-z") 'zap-up-to-char)
#+END_SRC

Input special characters by typing the TeX code for them.

#+BEGIN_SRC emacs-lisp
  (setq default-input-method "TeX")
#+END_SRC

By default, Emacs searches for the ends of sentences by looking for a
full stop and two spaces. I'm not in the habit of writing two spaces
after a full stop, so I need it to look for one space, instead.

#+BEGIN_SRC emacs-lisp
  (setq sentence-end-double-space nil)
#+END_SRC

Emacs provides a feature called [[https://www.emacswiki.org/emacs/HippieExpand][hippie-expand]] which tries to expand
the word at the point into something more useful. It just needs to be
bound to a keystroke.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-/") 'hippie-expand)
#+END_SRC

** Spell-Checking

Emacs has a built-in spellchecker, [[https://www.emacswiki.org/emacs/FlySpell][Flyspell]], which works by shelling
out to another program, such as Ispell, Aspell, or Hunspell. If you're
on Windows, you're currently pretty much stuck with the old version of
Hunspell from EZWinPorts. If you find something better, please let me
know. If you're on Linux or macOS, my understanding is that GNU Aspell
is faster, but Hunspell has better language support; you should be
able to get either through your package manager.

#+BEGIN_SRC emacs-lisp
  (use-package ispell
    :defer t
    :custom
    (ispell-program-name (if *my/is-winnt* "hunspell" "aspell"))
    (ispell-dictionary "en_US"))

  (use-package flyspell
    :delight (flyspell-mode " ~")
    :hook ((text-mode . flyspell-mode)
           (prog-mode . flyspell-prog-mode)))
#+END_SRC

** Emacs Server

By starting an Emacs server, we can use /emacsclient/ to open files in
our current Emacs session. I've disabled this section, as I use a
systemd user service to run Emacs.

#+BEGIN_SRC emacs-lisp :tangle no
  (add-hook 'after-init-hook #'server-start)
#+END_SRC

** Apropos

The [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Apropos.html][apropos system]] is used for finding relevant commands. This option
expands the search to look for more stuff.

#+BEGIN_SRC emacs-lisp
  (setq apropos-do-all t)
#+END_SRC

** Ediff

The built-in [[https://www.emacswiki.org/emacs/EdiffMode][ediff-mode]] provides an interface for diffing files and
working with patches. By default it launches into a separate frame,
but we can tell it to load in the current frame instead. Additionally,
it's nicer if it displays windows side-by-side instead of stacked
vertically.

#+BEGIN_SRC emacs-lisp
  (setq ediff-window-setup-function 'ediff-setup-windows-plain
        ediff-split-window-function 'split-window-horizontally)
#+END_SRC

** Mixed-DPI

Because I often have a mixed-DPI setup, if I'm under X, I need to be
able to rescale an entire Emacs frame at a time on the fly, so I also
include keybindings for that. This can be hooked into for e.g. fixing
treemacs icons.

#+BEGIN_SRC emacs-lisp
  (defvar my/toggle-face-height-hook nil
    "Called when toggling the face height for mixed-DPI setups.")

  (defun my/current-default-face-height ()
    "Get the height of the default face in the current frame."
    (face-attribute 'default :height (selected-frame)))

  (defun my/toggle-face-height ()
    "Toggle the height of the default face in the current frame.
  Useful when moving Emacs frames between monitors in mixed-DPI setups."
    (interactive)

    (set-face-attribute 'default (selected-frame) :height
                        (if (> (my/current-default-face-height) 80) 60 100))
    (run-hooks 'my/toggle-face-height-hook))

  (global-set-key (kbd "C-x t s") 'my/toggle-face-height)
#+END_SRC

* Visual Flair

No point in setting up your editor so that it can make coffee and do
your taxes if you can't stand looking at it. This section customizes
the visual aspects of the Emacs experience, and is fairly modular.

** Libraries

The [[https://github.com/magnars/dash.el][dash.el]] library provides extended functionality for dealing with
lists in elisp. It's used in enough packages it'll end up in all but
the most conservative configs anyway, so it might as well get included
explicitly so that it can be used here.

#+BEGIN_SRC emacs-lisp
  (use-package dash :config (global-dash-fontify-mode))
#+END_SRC

** Initial Frame Size

Emacs starts with a tiny frame. This is less than useful on modern monitors.

#+BEGIN_SRC emacs-lisp :tangle early-init.el
  (add-to-list 'default-frame-alist '(width . 150))
  (add-to-list 'default-frame-alist '(height . 50))
#+END_SRC

** Fonts

I use [[https://github.com/belluzj/fantasque-sans][Fantasque Sans Mono]] for fixed-pitch text, and [[https://github.com/adobe-fonts/source-serif-pro][Source Serif Pro]]
for variable-pitch text.

#+BEGIN_SRC emacs-lisp :tangle early-init.el
  (add-to-list 'default-frame-alist
               '(font . "Fantasque Sans Mono-12"))

  (set-face-attribute 'variable-pitch nil
                      :family "Source Serif Pro"
                      :height 1.25)
#+END_SRC

The height of 1.25 is chosen because otherwise it's too small on my
screen, and the reciprocal is exactly 0.8, which is useful for
fixed-width text which, for some reason, inherits its height from the
=variable-pitch= face.

Several modern coding fonts supply coding ligatures, which e.g.
display >= as \ge. Emacs can use these, but needs to be told what
characters to consider for ligatures. This is a bit of a pain, but one
side-benefit is that ligatures that you dislike can be selectively
disabled.

The machinery for setting this up involves giving Emacs a set of
regular expressions grouped by the first character of the ligature.
The following function makes the appropriate arrangements
automatically.

#+BEGIN_SRC emacs-lisp
  (defun my/enable-compositions (ligatures)
    "Set up the `composition-function-table' for a list of LIGATURES."
    (-each (-group-by 'string-to-char ligatures)
      (-lambda ((char . comps))
        (set-char-table-range composition-function-table char
                              `([,(regexp-opt comps) 0 font-shape-gstring])))))
#+END_SRC

All that remains is to pass in the strings that should become
ligatures.

#+BEGIN_SRC emacs-lisp
  (defvar my/compositions
    '("!=" "!=="
      "==" "===" "=>" "==>" "=>>" "=/=" "=<<"
      "->" "-->" "->>" "-<" "-<<"
      "<-" "<-<" "<<-" "<--" "<->" "<=<" "<<=" "<==" "<=>" "<~~" "<~" "<<<"
      "<<" "<=" "<~>" "<>" "<|||" "<||" "<|" "<|>" "<!--"
      ">->" ">=>" ">>=" ">>-" ">-" ">=" ">>" ">>>"
      "~~" "~>" "~~>"
      "|>" "||>" "|||>" "||"
      "::" "&&"
      ;; "//"  ;; c++-mode hangs when this is enabled???
      "/*" "/**/"
      "*/"))
  (my/enable-compositions my/compositions)
#+END_SRC

If the ligatures included in your font aren't enough for you, Emacs
has [[https://emacsredux.com/blog/2014/08/25/a-peek-at-emacs-24-dot-4-prettify-symbols-mode/][prettify-symbols-mode]], which can visually replace strings with
other strings, e.g. make the =lambda= elisp keyword display as =\lambda=.
It can be turned on per-buffer, per-mode, or globally. I find it
disruptive when enabled globally, but I may yet revisit it.

#+BEGIN_SRC emacs-lisp
  (global-prettify-symbols-mode -1)
#+END_SRC

** Color Scheme

I like [[https://github.com/morhetz/gruvbox][gruvbox]] ([[https://github.com/greduan/emacs-theme-gruvbox][Emacs version]]), which provides both dark and light
versions in a variety of contrast levels, and theming information for
a variety of common extensions.

#+BEGIN_SRC emacs-lisp :tangle early-init.el
  (use-package gruvbox-theme
    :demand t
    :config
    (setq my/light-theme 'gruvbox-light-medium)
    (setq my/dark-theme 'gruvbox-dark-soft)
    (setq my/initial-theme my/dark-theme)
    (load-theme my/initial-theme t))
#+END_SRC

For eye-comfort, it's worth making it easy to toggle between dark and
light versions depending on the environment.

#+BEGIN_SRC emacs-lisp
  (defun my/toggle-theme ()
    "Toggle between dark and light themes."
    (interactive)

    (let ((is-dark (seq-contains-p custom-enabled-themes my/dark-theme)))
      (-each custom-enabled-themes 'disable-theme)
      (load-theme (if is-dark my/light-theme my/dark-theme) t)))

  (global-set-key (kbd "C-x t t") 'my/toggle-theme)
#+END_SRC

** Icons

[[https://github.com/domtronn/all-the-icons.el][All The Icons]] provides a set of icon-font based icons which can be
used by several other packages. You need to run =M-x
all-the-icons-install-fonts= before it will work.

#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons)
#+END_SRC

** Mode Line

The default Emacs modeline is pretty plain. I'm now using
[[https://github.com/seagle0128/doom-modeline][doom-modeline]]. I've also tried out [[https://github.com/TheBB/spaceline][Spaceline]] and [[https://github.com/milkypostman/powerline][Powerline]]; they're
fine, I just found this to be easier to work with.

#+BEGIN_SRC emacs-lisp
  (use-package doom-modeline
    :custom
    (doom-modeline-major-mode-icon nil)
    (doom-modeline-height 40)
    (doom-modeline-project-detection 'projectile)
    (doom-modeline-minor-modes t)
    (doom-modeline-checker-simple-format nil)
    (doom-modeline-gnus nil)
    (doom-modeline-irc nil)
    :config
    (progn
      (doom-modeline-mode +1)
      (column-number-mode +1)))
#+END_SRC

Once a few minor modes are enabled, the modeline can get cluttered.
The [[https://www.emacswiki.org/emacs/DelightedModes][delight]] package can help with this, by abbreviating or eliding
mode names. =use-package= integrates with it as well. Some of the modes
enabled in the [[Prelude]] section can benefit from this.

#+BEGIN_SRC emacs-lisp
  (use-package delight)
  (use-package emacs
    :delight
    (auto-fill-function " $")
    (visual-line-mode))
#+END_SRC

** Nicer Form Feeds

Some elisp files use the form-feed character to separate sections
(along with some Emacs modes---I'm looking at you,
=elisp-compile-mode=). We can display them as lines using
[[https://github.com/purcell/page-break-lines][page-break-lines]] (or [[https://depp.brause.cc/form-feed/][form-feed]], if you're using Emacs in text mode).

#+BEGIN_SRC emacs-lisp
  (use-package page-break-lines
    :delight page-break-lines-mode
    :config (global-page-break-lines-mode +1))
#+END_SRC

* Core Enhancements

This is, effectively, part 2 of the [[Prelude]] section. The difference is
that while the Prelude only brings in a package if it's absolutely
essential, this section brings in packages which do at least one of
two things:

+ Improve or replace built-in Emacs features in a way that's broadly
  useful.
+ Add features that are useful in practically every context.

The packages in this section either show up in many Emacs configs, or
are part of a class of packages one of which shows up in many Emacs
configs.

** Libraries

[[https://github.com/raxod502/prescient.el][prescient.el]] is used to order searches by frecency. Make changes to
its options here; integration with other packages is located with
those packages.

#+BEGIN_SRC emacs-lisp
  (use-package prescient
    :config (prescient-persist-mode +1))
#+END_SRC

** Keybindings

The [[https://github.com/abo-abo/hydra][Hydra]] library provides tools for constructing groups of
keybindings that require fewer keypresses by allowing a prefix to be
implied if the previous keybinding was part of the same group.

#+BEGIN_SRC emacs-lisp
  (use-package hydra)
#+END_SRC

May Emacs keybindings require a sequence of keystrokes. Which keys do
what in which mode can be hard to remember; this provides a popup that
shows [[https://github.com/justbur/emacs-which-key][which-key]] you might need next.

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :delight which-key-mode
    :config (which-key-mode +1))
#+END_SRC

** Text Completion

Emacs features completion abilities, but [[https://company-mode.github.io/][company-mode]] expands those
into a framework that other modes can build on.

#+BEGIN_SRC emacs-lisp
  (use-package company
    :demand t
    :delight company-mode
    :hook (after-init . global-company-mode))

  (use-package company-prescient
    :config (company-prescient-mode +1))
#+END_SRC

Less dramatically, [[https://github.com/Fuco1/smartparens][Smartparens]] helps insert paired characters for you.
This config uses the strict mode, which tries to help you out when
deleting text would cause delimiters to become unbalanced. It's
enabled automatically for programming modes.

#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :delight (smartparens-mode " ()")
    :hook ((prog-mode . smartparens-mode)
           (emacs-lisp-mode . smartparens-strict-mode))
    :config
    (require 'smartparens-config))
#+END_SRC

To go with that, [[https://github.com/Fanael/rainbow-delimiters][rainbow-delimiters]] helps make it easy to see what's
going on with those parentheses.

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode))
#+END_SRC

** Minibuffer Completion

Emacs has minibuffer completion built-in in the form of [[https://www.emacswiki.org/emacs/InteractivelyDoThings][ido-mode]].
However, there are two more advanced completion frameworks available:
[[https://github.com/abo-abo/swiper][Ivy]] and [[https://github.com/emacs-helm/helm][Helm]]. Both have wide support, but at time of writing, the Helm
maintainer [[https://github.com/emacs-helm/helm/issues/2386][had just halted development]]. I ended up switching to Ivy,
which I rather like so far.

#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :demand t
    :delight ivy-mode
    :bind (("C-c C-r" . ivy-resume)
           ("C-x B" . ivy-switch-buffer-other-window))
    :custom
    (ivy-count-format "(%d/%d) ")
    (ivy-use-virtual-buffers t)
    (ivy-virtual-abbreviate 'full)
    :config (ivy-mode +1))
#+END_SRC

Ivy pairs well with Counsel, from the same repository, which
integrates Ivy with a variety of built-in Emacs features.

#+BEGIN_SRC emacs-lisp
  (use-package counsel
    :after ivy
    :delight counsel-mode
    :config (counsel-mode +1))
#+END_SRC

=prescient.el= integrates with Ivy, and sort of de-integrates with
Counsel.

#+BEGIN_SRC emacs-lisp
  (use-package ivy-prescient
    :after counsel
    :config (ivy-prescient-mode +1))
#+END_SRC

In order to display more information in Ivy minibuffers, [[https://github.com/Yevgnen/ivy-rich][ivy-rich]] adds
the concept of transformers, and defines some useful default ones,
which can display extra information (such a docstrings) inside Ivy
menus.

#+BEGIN_SRC emacs-lisp
  (use-package ivy-rich
    :after (ivy counsel all-the-icons-ivy-rich)
    :custom
    (ivy-rich-path-style 'abbrev)
    :config
    (setcdr (assq t ivy-format-functions-alist) #'ivy-format-function-line)
    (ivy-rich-mode +1))
#+END_SRC

For example, we can have icons in there.

#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons-ivy-rich
    :after counsel-projectile
    :config (all-the-icons-ivy-rich-mode +1))
#+END_SRC

** Searching

Expanding on the Ivy configuration above, Swiper, again part of the
same project, provides a nifty search interface in the minibuffer.

#+BEGIN_SRC emacs-lisp
  (use-package swiper
    :after ivy
    :bind (("C-s" . swiper)))
#+END_SRC

Additionally, I like having TODO/FIXME/etc. comments highlighted with
a dedicated search feature. [[https://github.com/tarsius/hl-todo][hl-todo]] provides this, and we can give it
a nice Hydra map.

#+BEGIN_SRC emacs-lisp
  (use-package hl-todo
    :demand t
    :config
    (progn
      (defun my/hl-todo-swiper ()
        "Search for TODOs in Swiper"
        (interactive)
        (swiper (substring (hl-todo--regexp) 2 -2)))

      (defhydra hydra-hl-todo (hl-todo-mode-map "C-c")
        "Search TODOs"
        ("N" hl-todo-previous "previous")
        ("n" hl-todo-next "next")
        ("s" my/hl-todo-swiper "swiper" :exit t)
        ("o" hl-todo-occur "occur" :exit t)
        ("i" hl-todo-insert "insert" :exit t))
      (global-hl-todo-mode +1)))
#+END_SRC

** Syntax Checking

[[https://www.flycheck.org][Flycheck]] is a replacement for the built-in Flymake. Several
language-specific modes can be configured to take advantage of it.

#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :demand t
    :delight flycheck-mode  ; doom-modeline has a dedicated indicator for this
    :hook (after-init . global-flycheck-mode))
#+END_SRC

** Projects

Emacs doesn't really have a concept of projects, i.e. groups of
related files, as such. It's useful, though, and [[https://github.com/bbatsov/projectile][Projectile]] provides a
framework and features for working with this.

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :delight (projectile-mode
              (:eval (format " p:%s" (projectile-project-type))))
    :bind-keymap ("C-c p" . projectile-command-map)
    :bind (("<f7>" . projectile-compile-project)
           ("<f5>" . projectile-run-project))
    :custom
    (projectile-completion-system 'ivy)
    :config (projectile-discover-projects-in-search-path))
#+END_SRC

It natively supports Ivy, but [[https://github.com/ericdanan/counsel-projectile][counsel-projectile]] takes the integration
further.

#+BEGIN_SRC emacs-lisp
  (use-package counsel-projectile
    :config (counsel-projectile-mode +1))  ; also enables projectile-mode
#+END_SRC

** Undo/Redo

Tree-style undo/redo via [[http://www.dr-qubit.org/undo-tree.html][undo-tree]] (also [[https://www.emacswiki.org/emacs/UndoTree][wiki]]).

#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :delight undo-tree-mode
    :custom
    (undo-tree-visualizer-timestamps t)
    (undo-tree-visualizer-diff t)
    :config (global-undo-tree-mode +1))
#+END_SRC

** Window Management

I'm currently using [[https://github.com/abo-abo/ace-window][ace-window]] for navigating windows, since Treemacs
depends on it anyway (see [[File Explorer]]). Another option is [[https://github.com/deb0ch/emacs-winum][winum]].

#+BEGIN_SRC emacs-lisp
  (use-package ace-window
    :demand t
    :custom
    (aw-display-mode-overlay nil)
    (aw-dispatch-always t)
    (aw-background nil)
    :bind ("C-x o" . ace-window)
    :config (ace-window-display-mode +1))
#+END_SRC

** File Explorer

I find it helpful to have a tree-style file explorer in a sidebar.
[[https://github.com/Alexander-Miller/treemacs][Treemacs]] provides this feature. I have it bound into the =ace-window=
keymap.

#+BEGIN_SRC emacs-lisp
  (use-package treemacs
    :hook (after-init . treemacs-select-window)  ; open on start
    :config
    (progn
      (add-to-list 'aw-dispatch-alist '(?t treemacs-select-window))
      (add-to-list 'aw-dispatch-alist '(?T treemacs))
      (treemacs-git-mode 'deferred)
      (treemacs-filewatch-mode 1)
      (define-key treemacs-mode-map [mouse-1]
        #'treemacs-single-click-expand-action)))
#+END_SRC

It also integrates with =projectile-mode= (see [[Projects]]).

#+BEGIN_SRC emacs-lisp
  (use-package treemacs-projectile
    :after (treemacs projectile))
#+END_SRC

It also needs to be hooked into the [[Mixed-DPI]] helper, otherwise the
icon sizes end up wrong.

#+BEGIN_SRC emacs-lisp
  (add-hook 'my/toggle-face-height-hook
            #'(lambda ()
                (treemacs-resize-icons
                 (if (> (my/current-default-face-height) 80) 22 11))))
#+END_SRC

If All The Icons was installed, Treemacs can use them.

#+BEGIN_SRC emacs-lisp
  (use-package treemacs-all-the-icons
    :requires all-the-icons
    :config (treemacs-load-theme 'all-the-icons))
#+END_SRC

** Git

[[https://magit.vc/][Magit]] is a Git porcelain, and can be considered one of the killer apps
for Emacs. Never leave home without it. It's good enough that, as a
longtime Mercurial fan, I stoppped using it for personal projects
because it didn't work with Magit.

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :bind ("C-x g" . magit-status))
#+END_SRC

We do need to tell =auto-fill-mode= to wrap at 72 instead of whatever it
was wrapping at before. (The =git-commit= package is part of Magit.)

#+BEGIN_SRC emacs-lisp
  (use-package git-commit
    :hook (git-commit-mode . (lambda () (setq fill-column 72))))
#+END_SRC

Treemacs provides a Magit integration so that it knows when to redo
highlighting for which files are staged/unstaged.

#+BEGIN_SRC emacs-lisp
  (use-package treemacs-magit
    :after (treemacs magit))
#+END_SRC

It's also handy to show which lines have changed in the fringe.
[[https://github.com/emacsorphanage/git-gutter-fringe][git-gutter-fringe]] provides that.

#+BEGIN_SRC emacs-lisp
  (use-package git-gutter-fringe
    :delight git-gutter-mode
    :config (global-git-gutter-mode +1))
#+END_SRC

[[https://github.com/magit/git-modes][Git Config Modes]] for editing common config files. Some of these are
useful for similar files from other tools (e.g. ignore files).

#+BEGIN_SRC emacs-lisp
  (use-package git-modes
    :mode (("/\\.gitattributes\\'" . gitattributes-mode)
           ("/info/attributes\\'" . gitattributes-mode)
           ("/git/attributes\\'" . gitattributes-mode)
           ("/\\.gitconfig\\'" . gitconfig-mode)
           ("/\\.git/config\\'" . gitconfig-mode)
           ("/modules/.*/config\\'" . gitconfig-mode)
           ("/git/config\\'" . gitconfig-mode)
           ("/\\.gitmodules\\'" . gitconfig-mode)
           ("/etc/gitconfig\\'" . gitconfig-mode)
           ("/\\.gitignore\\'" . gitignore-mode)
           ("/info/exclude\\'" . gitignore-mode)
           ("/git/ignore\\'" . gitignore-mode)))
#+END_SRC

* Evil

As a VIM refugee with modal editing burned into my fingers, I really
like [[https://github.com/emacs-evil/evil][Evil]]. It emulates /vi/ inside of Emacs, and it does it really well.
If you are not used to VIM, you do not want anything to do with this
section.

#+BEGIN_SRC emacs-lisp
  (defun my/c-c ()
    "Start a key sequence for a major mode command."
    (interactive)
    (setq unread-command-events (listify-key-sequence (kbd "C-c"))))

  (defun my/c-x ()
    "Start a key sequence for a general command."
    (interactive)
    (setq unread-command-events (listify-key-sequence (kbd "C-x"))))

  (use-package evil
    :demand t
    :bind (("C-x SPC" . counsel-M-x)      ; available as SPC SPC
           :map evil-normal-state-map
           ("SPC" . my/c-x)
           ("," . my/c-c)
           ;; Swiper integration
           ("/" . swiper)
           ("?" . swiper-backward)
           ("*" . swiper-thing-at-point))
    :custom
    (evil-undo-system 'undo-tree)
    (evil-search-module 'evil-search)  ; fixes the thing where nN always go backward
    :config
    (evil-mode +1))
#+END_SRC

At this time, I don't make any particular effort to rebind things to
/vi/-style keybindings; I mostly care about basic editing. However, some
modes don't work properly without being told about Evil, so the rest
of this section does just that. It's organized by package, rather than
feature.

** Magit

Evil provides an [[https://github.com/emacs-evil/evil-magit][Evil-Magit]] integration.

#+BEGIN_SRC emacs-lisp
  (use-package evil-magit
    :after (evil magit))
#+END_SRC

** TODO Smartparens

Add the fancy paren handling into Evil with [[https://github.com/luxbock/evil-cleverparens][evil-cleverparens]]. (See
[[Text Completion]])

#+BEGIN_SRC emacs-lisp
  (use-package evil-cleverparens
    :delight evil-cleverparens-mode
    :hook (lisp-mode . evil-cleverparens-mode))
#+END_SRC

** Treemacs

Treemacs provides an integration for Evil.

#+BEGIN_SRC emacs-lisp
  (use-package treemacs-evil
    :after (treemacs evil))
#+END_SRC

* Extended Enhancements

Additional enhancements that are less-generally useful. May get moved
up to Prelude or Core Enhancements as I see fit.

** Fast Restart

Botched your Emacs state? Made changes to the init code that require a
full restart? Want to spend as little time outside Emacs as possible
while restarting? Then just =M-x= [[https://github.com/iqbalansari/restart-emacs][restart-emacs]] and get on with your
work.

#+BEGIN_SRC emacs-lisp
  (use-package restart-emacs
    :commands restart-emacs)
#+END_SRC

(Provided that you /are/ working, instead of fussing over your initfiles
like me.)

** Prettier Autocomplete

[[https://github.com/sebastiencs/company-box][company-box]] makes the autocomplete popup a bit prettier, and also
causes it to not be a jumbled mess in buffers using variable-pitch
fonts.

#+BEGIN_SRC emacs-lisp
  (use-package company-box
    :delight
    :hook (company-mode . company-box-mode))
#+END_SRC

** Window Management II

The [[https://github.com/bmag/emacs-purpose][window-purpose]] package allows windows to be "dedicated" to buffers
with a particular purpose. Handy if you want to avoid your compilation
buffer leaping around taking over windows.

#+BEGIN_SRC emacs-lisp
  (use-package window-purpose
    :bind (:map purpose-mode-map
                ("C-x b" . nil)
                ("C-x C-f" . nil))
    :config
    (purpose-mode +1)
    (require 'window-purpose-x)
    (purpose-x-magit-single-on))
#+END_SRC

The =C-x b= and =C-x C-f= bindings override the ones from Counsel, so
those are unmapped as suggested for if you're using Helm. I'm not sure
that the =window-purpose= versions get you, but it seems to work fine
for now.

** EditorConfig

Provides support for [[https://editorconfig.org/][EditorConfig]] files.

#+BEGIN_SRC emacs-lisp
  (use-package editorconfig
    :ensure t
    :config
    (editorconfig-mode +1))
#+END_SRC

* Languages
** Common

Many languages now have Language Server Protocol backends for them.
For Emacs, [[https://github.com/emacs-lsp/lsp-mode/][lsp-mode]] allows us to take advantage of these. The
language-specific configurations are grouped under the relevant
headers, including the hooks.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package lsp-mode
    :hook ((lsp-mode . lsp-enable-which-key-integration))
    :custom
    (lsp-keymap-prefix "C-l")
    :commands lsp)

  (use-package lsp-ui
    :commands lsp-ui-mode)

  (use-package lsp-ivy  ; ivy integration
    :commands lsp-ivy-workspace-symbol)

  (use-package lsp-treemacs  ; treemacs integration
    :commands lsp-treemacs-errors-list)
#+END_SRC

[[https://www.emacswiki.org/emacs/ElDoc][El Doc]] gets pulled in a lot (LSP uses it), and it's generally obvious
that it's present because you start getting lots of little popups, so
it doesn't need a lighter.

#+BEGIN_SRC emacs-lisp
  (delight 'eldoc-mode nil t)
#+END_SRC

** TODO C/C++

Still need to test some of this, get the kinks worked out on Windows,
and review [[https://oremacs.com/2017/03/28/emacs-cpp-ide/]] for more
stuff. Maybe pull in the packages suggested on the irony-mode page,
too.

Emacs already has a respectable C/C++ mode, but [[https://github.com/Sarcasm/irony-mode][irony-mode]] can take
advantage of libclang to improve the experience.

#+BEGIN_SRC emacs-lisp
  (defun my/indent-setup ()
    (c-set-offset 'arglist-intro '+))

  (add-hook 'c-mode-hook #'my/indent-setup)
  (add-hook 'c++-mode-hook #'my/indent-setup)

  (use-package irony
    :hook (((c++-mode c-mode objc-mode) . irony-mode)
           (irony-mode . irony-cdb-autosetup-compile-options))
    :init
    (when *my/is-winnt*
      (add-to-list 'exec-path (expand-file-name "~/scoop/apps/llvm/10.0.0/bin") t)

      ;; Suggested in the documentation to improve performance.
      (when (boundp 'w32-pipe-read-delay)
        (setq w32-pipe-read-delay 0))
      (when (boundp 'w32-pipe-buffer-size)
        (setq irony-server-w32-pipe-buffer-size (* 64 1024)))))

  (use-package flycheck-irony
    :hook ((flycheck-mode . flycheck-irony-setup)))

  (use-package company-irony
    :config
    (add-to-list 'company-backends 'company-irony))

  (use-package irony-eldoc
    :hook ((irony-mode . irony-eldoc)))
#+END_SRC

In theory [[https://github.com/atilaneves/cmake-ide][cmake-ide]] should provide a bunch of bells and whistles, but
the documentation is a bit sparse. [[https://github.com/randomphrase/company-c-headers][company-c-headers]] might be worth a
look as well.

*** CUDA

A simple [[https://github.com/chachi/cuda-mode][cuda-mode]] which provides font-lock features. Could get most
of the way there by just adding entries for =c++-mode= to
=auto-mode-alist=.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package cuda-mode
    :mode (("\\.cu\\'" . cuda-mode)
           ("\\.cuh\\'" . cuda-mode)))
#+END_SRC

** Dhall

#+BEGIN_SRC emacs-lisp
  (use-package dhall-mode)
#+END_SRC

** elisp

Emacs has pretty much everything you need for working with elisp, but
if you're byte-compiling those files, it's good to [[https://github.com/emacscollective/auto-compile][auto-compile]] so
that the bytecode stays up-to-date. (Note that =straight.el= will handle
compiling packages itself.) This wants to be set up as early as
possible, so it goes into our =early-init.el=.

#+BEGIN_SRC emacs-lisp :tangle early-init.el
  (use-package auto-compile
    :config
    (auto-compile-on-load-mode +1)
    (auto-compile-on-save-mode +1))
#+END_SRC

** fish shell

A [[https://github.com/wwwjfy/emacs-fish][fish-mode]] for working with [[https://fishshell.com/][fish shell]], which is what I use on UNIXy
systems.

#+BEGIN_SRC emacs-lisp
  (use-package fish-mode
    :hook (fish-mode . (lambda ()
                         (add-hook 'before-save-hook 'fish_indent-before-save)))
    :mode (("\\.fish\\'" . fish-mode)
           ("/fish_funced\\..*\\'" . fish-mode))
    :interpreter ("fish" . fish-mode))
#+END_SRC

** TODO Go

Golang development with [[https://github.com/dominikh/go-mode.el][go-mode.el]]. I tried out [[https://github.com/mdempsky/gocode][company-go]] but it
turned out to be intolerably slow; I understand that using LSP with
[[https://github.com/golang/tools/blob/master/gopls/README.md][gopls]] is now the preferred option. I haven't done much Go lately so
this will sit around as-is until I need it again.

#+BEGIN_SRC emacs-lisp :tangle no
  ;; (use-package company-go)
  (use-package go-mode
    :mode ("\\.go\\'". go-mode)
    :init
    (progn
      (defun my/go-mode-locals ()
        ;; (set (make-local-variable 'company-backends) '(company-go))
        ;; (company-mode 1)
        (setq tab-width 3))
      (add-hook 'go-mode-hook #'my/go-mode-locals)
      (add-hook 'go-mode-hook #'flycheck-mode)
      (add-hook 'before-save-hook #'gofmt-before-save)))
#+END_SRC

** Kubernetes

#+BEGIN_SRC emacs-lisp
  (use-package kubernetes
    :commands (kubernetes-overview))

  (use-package kubernetes-evil
    :after kubernetes)
#+END_SRC

** Lua

[[https://immerrr.github.io/lua-mode/][lua-mode]] for writing Lua.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package lua-mode
    :commands (lua-mode)
    :mode ("\\.lua\\'" . lua-mode)
    :interpreter ("lua" . lua-mode))
#+END_SRC

** Markdown

[[https://github.com/jrblevin/markdown-mode][Markdown Mode]] for writing Markdown.

#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :mode (("README\\.md\\'" . gfm-mode)
           ("\\.md\\'" . markdown-mode)
           ("\\.markdown\\'" . markdown-mode))
    :custom (markdown-command '("pandoc" "--from=markdown" "--to=html5")))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (define-minor-mode my/writer-mode
    "Minor mode for writing prose."
    :init-value nil :lighter nil :global nil
    (if my/writer-mode
        (my/writer-mode--enable)
      (my/writer-mode--disable)))

  (defface my/writer-mode-default-face
    '((t :inherit font-lock-comment-face
         :family "iA Writer Duo S"
         :height 1.20))
    "Default face for body text.")

  (defface my/writer-mode-hl-line-face
    '((t :foreground "#ebdbb2"))
    "Default face for current line.")

  (defun my/writer-mode--window-max-text-width (&optional window)
    "Return the maximum possible text width of WINDOW."
    (or window (setq window (selected-window)))
    (let* ((margins (window-margins window))
           (buffer (window-buffer window))
           (scale (if (and (boundp 'text-scale-mode-step)
                           (boundp 'text-scale-mode-amount))
                      (with-current-buffer buffer
                        (expt text-scale-mode-step
                              text-scale-mode-amount))
                    1.0)))
      (truncate (/ (+ (window-width window)
                      (or (car margins) 0)
                      (or (cdr margins) 0))
                   (float scale)
                   1.1))))

  (defun my/writer-mode--adjust-window (&optional window)
    "Adjust the margins and fringes of WINDOW."
    (or window (setq window (selected-window)))
    (with-selected-window window
      (when my/writer-mode
        (set-window-fringes window nil nil t)
        (set-window-parameter window 'min-margins '(0 . 0))
        (let* ((total-width (my/writer-mode--window-max-text-width window))
               (margins (max 0 (- total-width fill-column))))
          (set-window-margins window (/ margins 2))))))

  (defun my/writer-mode--enable ()
    "Set up `my/writer-mode' for the current buffer."
    (add-hook 'window-configuration-change-hook
              #'my/writer-mode--adjust-window 'append 'local)
    (add-hook 'window-state-change-functions
              #'my/writer-mode--adjust-window 'append 'local)
    (set (make-local-variable 'buffer-face-mode-face) 'my/writer-mode-default-face)
    (set (make-local-variable 'hl-line-face) 'my/writer-mode-hl-line-face)
    (buffer-face-mode +1)
    (hl-line-mode +1)
    (setq fill-column 70))

  (defun my/writer-mode--disable ()
    "Disable `my/writer-mode' for the current buffer."
    (remove-hook 'window-configuration-change-hook
                 #'my/writer-mode--adjust-window 'local)
    (remove-hook 'window-state-change-functions
                 #'my/writer-mode--adjust-window 'local)
    (buffer-face-mode -1)
    (hl-line-mode -1)
    (setq fill-column (default-value 'fill-column))
    (let ((window (get-buffer-window (current-buffer))))
      (set-window-margins window 0 0)
      (set-window-parameter window 'min-margins nil)
      (set-window-fringes window nil)))
#+END_SRC

** TODO MATLAB

There's a [[http://matlab-emacs.sourceforge.net/][MATLAB/Emacs integration]] mode. Normally, =.m= files are
treated as Objective-C files. I don't really do any ObjC, so they're
going to be treated as MATLAB files instead.

Except I don't do MATLAB anymore either, so this is disabled until it
once again darkens my desktop.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package matlab-mode
    :mode "\\.m\\'"
    :init
    (progn
      (setq matlab-indent-function t)  ; TODO figure out what this does
      (setq matlab-shell-command "/usr/local/bin/matlab")))
#+END_SRC

** Org-Mode

Of course we want the full-fat [[https://orgmode.org/][Org mode]]. Which I really should learn
to use more effectively.

#+BEGIN_SRC emacs-lisp
  (use-package org
    :mode ("\\.org\\'" . org-mode)
    :bind (("C-c l" . org-store-link)
           ("C-c a" . org-agenda)
           ("C-c c" . org-capture))
    :custom
    (org-log-done t)
    (org-hide-emphasis-markers t))
#+END_SRC

[[https://github.com/hniksic/emacs-htmlize][htmlize]] isn't /strictly/ part of Org, but it's needed for the export to
HTML feature and I'm not really sure where else to put it.

#+BEGIN_SRC emacs-lisp
  (use-package htmlize
    :commands (htmlize-buffer
               htmlize-region
               htmlize-file
               htmlize-many-files
               htmlize-many-files-dired))
#+END_SRC

This uses [[https://github.com/cadadr/elisp/blob/devel/org-variable-pitch.el][org-variable-pitch.el]] to make Org buffers, which tend to be
full of running text, more readable. I honestly thought this wouldn't
be very good but so far I quite like it. It /does/ mess up the
autocomplete popup unless you're using something like =company-box=,
though.

#+BEGIN_SRC emacs-lisp
  (delight 'buffer-face-mode nil t)
  (use-package org-variable-pitch
    :delight
    (org-variable-pitch-minor-mode)
    :hook (org-mode . org-variable-pitch--enable)
    :config
    (set-face-attribute 'org-variable-pitch-fixed-face nil
                        :family (org-variable-pitch--get-fixed-font)
                        :height 0.8)
    (set-face-attribute 'org-level-1 nil :height (+ 1.0 (expt 0.5 0)))
    (set-face-attribute 'org-level-2 nil :height (+ 1.0 (expt 0.5 1)))
    (set-face-attribute 'org-level-3 nil :height (+ 1.0 (expt 0.5 2)))
    (set-face-attribute 'org-level-4 nil :height (+ 1.0 (expt 0.5 3)))
    (set-face-attribute 'org-level-5 nil :height (+ 1.0 (expt 0.5 4)))
    (set-face-attribute 'org-level-6 nil :height (+ 1.0 (expt 0.5 5)))
    (set-face-attribute 'org-level-7 nil :height (+ 1.0 (expt 0.5 6)))
    (set-face-attribute 'org-level-8 nil :height (+ 1.0 (expt 0.5 7))))
#+END_SRC

[[https://spwhitton.name/tech/code/org-d20/][org-d20]] provides RPG tools for Org. I should really learn how to use
this, and maybe also move my campaign notes out a crappy notepad file
now that I have Emacs starting up faster.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package org-d20
    :commands org-d20-mode)
#+END_SRC

** TODO Ocaml

This is a huge mess of stuff that I found somewhere and didn't bother
to write down the URL where I found it, so now I have to puzzle it
back out again. Apparently [[https://github.com/leoliu/ggtags][ggtags]] was involved somehow but I never
actually got it set up. Better annotations when I fix this next time I
try to write some Ocaml.

I'm pretty sure this function is supposed to hunt down an elisp file
that =opam= creates for me, but I need to teach it about Windows too I
guess. Right now it's disabled so I don't get errors.

#+BEGIN_SRC emacs-lisp :tangle no
  (defun my/ocaml/init-opam ()
    (if (executable-find "opam")
        (let ((share (string-trim-right
                      (with-output-to-string
                        (with-current-buffer
                            standard-output
                          (process-file
                           shell-file-name nil '(t nil) nil shell-command-switch
                           "opam config var share"))))))
          (cond ((string= "" share)
                 (message "warning: `%s' output empty string." "opam config var share"))
                ((not (file-directory-p share))
                 (message "%s" "warning: opam share directory does not exist."))
                (t (setq opam-share share
                         opam-load-path (concat share "/emacs/site-lisp"))
                   (add-to-list 'load-path opam-load-path))))
      (unless (executable-find "ocamlmerlin")
        (message "warning: cannot find `%s' or `%s' executable." "opam" "merlin"))))
#+END_SRC

[[https://github.com/ocaml/tuareg][Tuareg]]

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package tuareg
    :mode (("\\.ml[ily]?$" . tuareg-mode)
           ("\\.topml$" . tuareg-mode))
    :init
    (progn
      ;; (my/ocaml/init-opam)
      (add-hook 'tuareg-mode-hook 'company-mode)
      (add-hook 'tuareg-mode-hook 'flycheck-mode)
      (dolist (ext '(".cmo" ".cmx" ".cma" ".cmxa" ".cmi" ".cmxs" ".cmt"
                     ".cmti" ".annot"))
        (add-to-list 'completion-ignored-extensions ext))))
#+END_SRC

[[https://github.com/ocaml/merlin][Merlin]]

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package merlin
    :delight (merlin-mode " ⚗")
    :hook (tuareg-mode . merlin-mode)
    :init
    (progn
      (add-to-list 'company-backends 'merlin-company-backend)))
#+END_SRC

[[https://github.com/OCamlPro/ocp-indent][ocp-indent]]

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package ocp-indent
    :hook (tuareg-mode . ocp-indent-caml-mode-setup))
#+END_SRC

... this should probably be up there in the Tuareg block.

#+BEGIN_SRC emacs-lisp :tangle no
  (with-eval-after-load 'smartparens
    (sp-local-pair 'tuareg-mode "'" nil :actions nil)
    (sp-local-pair 'tuareg-mode "`" nil :actions nil))
#+END_SRC

Setup for an inferior [[https://github.com/ocaml-community/utop][utop]].

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package utop
    :delight (utop-minor-mode " ū")
    :hook (tuareg-mode . utop-minor-mode)
    :config
    (progn
      (if (executable-find "opam")
          (setq utop-command "opam config exec -- utop -emacs")
        (message "warning: cannot find `opam' executable."))))
#+END_SRC

[[https://github.com/flycheck/flycheck-ocaml][flycheck-ocaml]]

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package flycheck-ocaml
    :after (flycheck merlin)
    :config
    (progn
      (setq merlin-error-after-save nil)
      (flycheck-ocaml-setup)))
#+END_SRC

Syntax highlighting and Projectile project type for [[https://github.com/ocaml/dune/tree/master/editor-integration/emacs][dune]].

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package dune
    :mode ("\\(?:\\`\\|/\\)dune\\(?:\\.inc\\)?\\'" . dune-mode)
    :commands (dune-promote dune-runtest-and-promote)
    :after projectile
    :init
    (projectile-register-project-type
     'dune '("dune-project")
     :compile "dune build"
     :test "dune runtest"))
#+END_SRC

** Python

Emacs includes a solid built-in =python-mode=, but since we have LSP
support, we can extend that a bit. (There are many other Python modes,
such as Elpy, but I jump between languages enough that I'm beginning
to value consistency a bit.)

This is currently disabled due to struggling with LSP.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package lsp-python-ms
    :defer t
    :custom
    (lsp-python-ms-auto-install-server t)
    (lsp-python-ms-executable (executable-find "Microsoft.Python.LanguageServer"))
    :hook (python-mode . (lambda ()
                           (require 'lsp-python-ms)
                           (lsp))))
#+END_SRC

Automatically format Python code on save using the Black formatter.

#+BEGIN_SRC emacs-lisp
  (use-package blacken
    :delight blacken-mode
    :hook (python-mode . blacken-mode))
#+END_SRC

** Rust

There are multiple Rust modes, and I settled on [[https://github.com/brotzeit/rustic][Rustic]] for
undocumented reasons. This is currently disabled because I haven't
been using Rust lately.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package rustic
    :mode ("\\.rs\\'" . rustic-mode))
#+END_SRC

** Scheme

Geiser, for great justice.

#+BEGIN_SRC emacs-lisp
  (use-package geiser)
  (use-package geiser-chicken)
  (use-package geiser-guile
    :custom (geiser-guile-binary "guile3"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path (expand-file-name "chicken" no-littering-etc-directory))
  (use-package chicken
    :custom (geiser-chicken-binary "chicken-csi")
    :straight nil)
#+END_SRC

** TODO TeX

So there's a built-in TeX mode, or we can add [[https://www.gnu.org/software/auctex/][AUCTeX]]. Right now this
assumes we're on Windows, using [[https://www.sumatrapdfreader.org/free-pdf-reader.html][Sumatra PDF]] as a viewer; I should
probably fix it to use Zathura or something.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package tex-site
    :straight auctex
    :mode ("\\.tex\\'" . TeX-latex-mode)
    :custom
    (TeX-parse-self t) ; Enable parse on load.
    (TeX-auto-save t) ; Enable parse on save.
    (TeX-view-program-list
     '(("SumatraPDF"
        ("SumatraPDF.exe -reuse-instance"
         (mode-io-correlate " -forward-search \"%b\" %n")
         " %o")
        "SumatraPDF")))
    (TeX-view-program-selection '((output-pdf "SumatraPDF")))
    (TeX-source-correlate-mode t)
    (TeX-source-correlate-method 'synctex))
#+END_SRC

** Zig

[[https://github.com/ziglang/zig-mode][zig-mode]] for syntax highlighting and auto-indentation.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package zig-mode
    :commands (zig-mode)
    :hook (zig-mode . lsp)
    :mode ("\\.zig\\'" . zig-mode))
#+END_SRC

Projectile integration.

#+BEGIN_SRC emacs-lisp :tangle no
  (with-eval-after-load 'projectile
    (projectile-register-project-type
     'zig '("build.zig")
     :compile "zig build"
     :test "zig build"))
#+END_SRC

... so I tried to set up an LSP server for Zig, but right now it
crashes whenever I open more than one file, which is a bit of of a
non-starter. Also, makes Windows-specific assumptions.

#+BEGIN_SRC emacs-lisp :tangle no
  (with-eval-after-load "lsp-mode"
    (add-to-list 'lsp-language-id-configuration '(zig-mode . "zig"))
    (lsp-register-client
     (make-lsp-client
      :new-connection (lsp-stdio-connection
                       (expand-file-name "~/Source/zls/zig-cache/bin/zls.exe"))
      :major-modes '(zig-mode)
      :server-id 'zls)))
#+END_SRC

* Machine-Specific Settings

Machine-specific settings are loaded by keying off of an string
constructed from the hostname and system type.

#+BEGIN_SRC emacs-lisp
  (defconst *my/local-id*
    (format "%s.%s" (downcase (system-name)) system-type)
    "Hostname-based identifier for the current installation.")

  (defvar my/local-config-count 0
    "The number of local configs that have been loaded.")

  (defmacro my/config-for-local-id (id &rest body)
    "Run BODY only on the installation identified by ID."
    (declare (indent defun))
    `(when (string= ,id *my/local-id*)
       (setq my/local-config-count (1+ my/local-config-count))
       ,@body))
#+END_SRC

Note that the machine-specific settings are loaded as the last thing,
after the rest of the init file has been processed. I mostly use these
for setting up installation paths for things which can vary between
machines, e.g. Python.

** Caladbolg

#+BEGIN_SRC emacs-lisp
  (my/config-for-local-id "caladbolg.berkeley-unix"
    (setq projectile-project-search-path '("~/src"))
    (setq treemacs-python-executable (executable-find "python3")))
#+END_SRC

** Galatine

#+BEGIN_SRC emacs-lisp
  (my/config-for-local-id "galatine.windows-nt"
    (setq projectile-project-search-path '("~/Source"))
    (setq treemacs-python-executable (executable-find "python"))
    (setq flycheck-python-pycompile-executable (executable-find "python"))
    (setq ispell-program-name (expand-file-name "~/bin/hunspell-current/bin/hunspell.exe")))
#+END_SRC

* Playground

Experimental, ad-hoc, questionable, and poorly-understood
configuration sections.

** TRAMP

I'm not quite sure what this is trying to accomplish, or whether it
accomplished it.

#+BEGIN_SRC emacs-lisp
  (setq-default explicit-shell-file-name "/bin/bash")
#+END_SRC

** Fortune

Gets a fortune from the web, and displays it in the =*scratch*= buffer.
On UNIX, we could use the actual /fortune/ program, but I can't find a
port of it for Windows.

#+BEGIN_SRC emacs-lisp
  (defvar my/fortune "https://api.justyy.workers.dev/api/fortune")

  (defun my/fortune ()
    "Insert a fortune from the web into the *scratch* buffer."
    (interactive)
    (let ((url-request-method "GET"))
      (url-retrieve
       my/fortune
       (lambda (status)
         (unless (plist-member status :error)
           (goto-char (point-min))
           (re-search-forward "^$")
           (let ((p (point)))
             (insert "[")
             (goto-char (point-max))
             (insert "]")
             (goto-char p))
           (let ((message (car (json-parse-buffer :array-type 'list))))
             (with-current-buffer "*scratch*"
               (goto-char (point-max))
               (let ((p (point)))
                 (insert message)
                 (comment-region p (point)))))
           (kill-buffer))))))

  ;; (my/fortune)
#+END_SRC

Potentially a better option would just be to teach Emacs how to read
fortune files itself. Also, the output would probably look nicer in a
formatted buffer, rather than tossed into an elisp buffer as a
comment.

** TODO Splash Screen

A groovy splash screen. Currently included in this repo.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path (expand-file-name "groovy-splash" no-littering-etc-directory))
  (use-package groovy-splash
    :straight nil
    :hook (after-init . groovy-splash-show)
    :custom
    (groovy-splash-segments '(groovy-splash-groovy-fill
                              groovy-splash-blank-line
                              groovy-splash-logo
                              groovy-splash-blank-line
                              groovy-splash-rule
                              groovy-splash-blank-line
                              groovy-splash-recentf
                              groovy-splash-blank-fill
                              groovy-splash-oracle
                              groovy-splash-blank-line)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package nasm-mode)
  (add-to-list 'load-path (expand-file-name "noweb-mode" no-littering-etc-directory))
  (use-package noweb-mode
    :straight nil)

  (use-package forth-mode
    :straight nil
    :load-path "lib")
#+END_SRC

* Coda

Write out completion messages after loading each of the main files.

#+BEGIN_SRC emacs-lisp :tangle early-init.el
  (message "early bird init complete")

  (provide 'early-init)
  ;;; early-init.el ends here
#+END_SRC

Additionally, for the =init.el=, we write out which machine-specific
section(s) we loaded.

#+BEGIN_SRC emacs-lisp
  (message "Loaded %d sections matching local id \"%s\""
           my/local-config-count *my/local-id*)
  (message "main init complete")

  (provide 'init)
  ;;; init.el ends here
#+END_SRC

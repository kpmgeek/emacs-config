#+TITLE: Emacs configuration file
#+AUTHOR: Jonathan David Page
#+PROPERTY: header-args:emacs-lisp :tangle init.el :noweb yes :lexical yes

* Prelude

  This file organizes settings from most-to-least general. If you're interested in
  basing your own configuration on mine, but don't want all of my bells and whistles (or
  you want different bells and whistles), then this is probably the section to keep. It
  describes a fairly minimal Emacs setup, with as few packages as possible.[fn:packages]
  In particular, it pulls in package management and sets up some sane defaults, many of
  which are pulled from the [[https://git.sr.ht/~technomancy/better-defaults][better-defaults package]].[fn:better-defaults]

  #+BEGIN_SRC emacs-lisp
    ;;; init.el --- main init   -*- lexical-binding: t -*-

    ;;; Commentary:
    ;; THIS IS A GENERATED FILE; changes should be made to README.org

    ;;; Code:
  #+END_SRC

  I use lexical binding (I believe now the default in Emacs 27.1) and a lot of
  byte-compilation. Now that we have =early-init.el=, we can byte-compile the main init
  file, as we can use it to tell Emacs that a newer uncompiled file should be preferred
  to the byte-compiled file.

  #+BEGIN_SRC emacs-lisp :tangle early-init.el
    ;;; early-init.el --- early bird init   -*- lexical-binding: t; no-byte-compile: t -*-

    ;;; Commentary:
    ;; THIS IS A GENERATED FILE; changes should be made to README.org

    ;;; Code:

    (setq load-prefer-newer t)
  #+END_SRC

[fn:packages] Specifically: =straight.el=, =use-package=, =auto-compile=, and on macOS,
=exec-path-from-shell=.

[fn:better-defaults] I originally used better-defaults directly, but got fed up with
having to peek inside it to check if a setting had already been configured.
Additionally, it sets up some things I don't care about: =ido-mode= (I use =ivy=) and
=isearch= (I use =swiper=). I include =ivy= and =swiper= when I spin off versions of this file
for people, so I haven't bothered to set up =ido-mode= and =isearch=. Check
=better-defaults= for how to enable them.

** Init File in Org-Mode

   To help keep things organized without creating an explosion of little files, the user
   configuration all lives in this =org-mode= file, =README.org=. On buffer save, it gets
   tangled into regular elisp files, =init.el=. If for some reason the auto-tangle doesn't
   work, it can be trigged manually with =org-babel-tangle= (=C-c C-v t=).

   #+BEGIN_SRC emacs-lisp
     (defun my/byte-compile-buffer-file ()
       (byte-compile-file buffer-file-name))

     (defun my/tangle-init ()
       "If the current buffer is 'README.org' in the user dir, the
            code blocks are tangled, and the tangled file is compiled."
       (when (equal (buffer-file-name)
                    (expand-file-name (concat user-emacs-directory "README.org")))
         ;; Avoid running hooks when tangling
         (let ((prog-mode-hook nil)
               (org-confirm-babel-evaluate nil))
           (add-hook 'org-babel-post-tangle-hook #'my/byte-compile-buffer-file)
           (org-babel-tangle)
           (remove-hook 'org-babel-post-tangle-hook #'my/byte-compile-buffer-file))))

     (add-hook 'after-save-hook 'my/tangle-init)
   #+END_SRC

   Since =init.el= gets overwritten constantly, leting Emacs add customizations to it
   isn't very useful. It should put them in a separate file instead. I personally don't
   use the custom interface, or if I do, I eventually incorporate the changes into this
   file, but I sometimes spin off versions of my config to help other people get
   started, and it's good for them to be able to use the customization interface.

   #+BEGIN_SRC emacs-lisp
     (setq custom-file (concat user-emacs-directory "custom.el"))
     (add-hook 'after-init-hook #'(lambda ()
                                    (message "loading %s" custom-file)
                                    (load custom-file t)))
   #+END_SRC

** Package Management & Auto-Compilation

   Package management and configuration is based on a combination of [[https://github.com/jwiegley/use-package][use-package]] for
   declarative package configuration, and [[https://github.com/raxod502/straight.el][straight.el]] for reproducible package
   installation. The [[file:straight/versions/default.el][lock file]] generated by =straight.el= is checked in alongside the
   configration. Between the two of these, I can delay loading packages until they're
   needed, and I can revert to older versions of packages if (when) something breaks.

   Some configuration options need to be set before the bootstrap code for =straight.el=
   is loaded. Specifically, we want =use-package= to automatically tell =straight.el= about
   the packages we're using so that they can be installed. The setting below prevents us
   from having to use the =:straight= option in =use-package= forms (which is the
   replacement for =:ensure=, which should not be used).

   #+BEGIN_SRC emacs-lisp :tangle early-init.el
     (setq straight-use-package-by-default t)
   #+END_SRC

   Because =straight.el= is installed before we've initialized any kind of package
   management, bootstrap code must be run to set it up. This is just copy-pasted from
   the README. Note that installing packages requires Git to be installed and in the
   path. It also requires a network connection.

   #+BEGIN_SRC emacs-lisp :tangle early-init.el
     (defvar bootstrap-version)
     (let ((bootstrap-file
            (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
           (bootstrap-version 5))
       (unless (file-exists-p bootstrap-file)
         (with-current-buffer
             (url-retrieve-synchronously
              "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
              'silent 'inhibit-cookies)
           (goto-char (point-max))
           (eval-print-last-sexp)))
       (load bootstrap-file nil 'nomessage))
   #+END_SRC

   Startup is much faster if we byte-compile all our libraries. The [[https://github.com/emacscollective/auto-compile][auto-compile]] package
   automates this. This wants to be set up as early as possible, and this is pretty much
   the earliest it can be set up during first run.

   #+BEGIN_SRC emacs-lisp :tangle early-init.el
     (straight-use-package 'auto-compile)
     (auto-compile-on-load-mode +1)
     (auto-compile-on-save-mode +1)
   #+END_SRC

   Now we can ask =straight.el= to install =use-package= for us.

   #+BEGIN_SRC emacs-lisp :tangle early-init.el
     (setq use-package-verbose t)
     (straight-use-package 'use-package)
     (require 'bind-key)  ; needed for byte-compilation
   #+END_SRC

** Platform-Specific Settings

   I've elected to group platform-specific settings with related platform-independant
   settings, rather than in one place. To assist with both writing them and locating
   them, I define some constants to test against and grep for.

*** GNU-Like Systems (incl. Windows)

    Some Emacs features need to be configured differently depending on whether or not
    the core utils installed support the options provided by the GNU versions of those
    tools. Personally, I don't install the GNU versions of tools on macOS and FreeBSD,
    since it can break other things, but I do install them on Windows. If your systems
    look different, you will need to change this.

    #+BEGIN_SRC emacs-lisp :tangle early-init.el
      (defconst *my/is-winnt*
        (or (string= "windows-nt" system-type)
            (string= "cygwin" system-type))
        "True if Emacs is running under Windows")

      (defconst *my/is-gnu-like*
        (or *my/is-winnt*  ; usually means GoW/Cygwin/MSYS2
            (string-prefix-p "gnu" (symbol-name system-type)))
        "True if we expect GNU-like coreutils")
    #+END_SRC

*** macOS

    While I've deployed versions of this config file to macOS, I don't test it often, so
    some changes may be required.

    #+BEGIN_SRC emacs-lisp :tangle early-init.el
      (defconst *my/is-macos*
        (memq window-system '(mac ns))
        "True if Emacs is running under macOS")
    #+END_SRC

    If you configure environment variables in your shell's config file, GUI applications
    will miss out on them. The [[https://github.com/purcell/exec-path-from-shell][exec-path-from-shell]] package fixes this by launching a
    shell and querying it.

    #+BEGIN_SRC emacs-lisp
      (use-package exec-path-from-shell
        :if *my/is-macos*
        :config
        (exec-path-from-shell-initialize))
    #+END_SRC

** Safety & Backups

   By default, Emacs keeps the previous version of each file around in a backup file,
   which is placed alongside the backed-up file. This makes them easy to find, but
   causes a lot of clutter. A better option is to store them all in one directory; this
   also makes it practical to keep multiple versions.

   #+BEGIN_SRC emacs-lisp
     (setq my/backup-directory (concat user-emacs-directory "backups"))
     (when (not (file-exists-p my/backup-directory))
       (make-directory my/backup-directory))
     (setq backup-directory-alist `(("." . ,my/backup-directory))
           backup-by-copying t    ; don't clobber symlinks
           version-control t      ; numbered backups
           delete-old-versions t  ; manage excess backups
           kept-old-versions 6
           kept-new-versions 9)
   #+END_SRC

   Delete files by moving them to the system trash, rather than unlinking them from the
   filesystem.

   #+BEGIN_SRC emacs-lisp
     (setq delete-by-moving-to-trash t)

     (when *my/is-macos*
       (defun system-move-file-to-trash (file)
         "Use \"trash\" to move FILE to the system trash.
          When using Homebrew, install it using \"brew install trash\"."
         (call-process (executable-find "trash")
                       nil 0 nil
                       file)))
   #+END_SRC

** History & Recent File Persistence

   Emacs can save your minibuffer history and several other histories to a file for you
   using the built-in [[https://www.emacswiki.org/emacs/SaveHist][savehist-mode]]. This allows them to persist across sessions.

   #+BEGIN_SRC emacs-lisp
     (use-package savehist
       :custom
       (savehist-file (concat user-emacs-directory "savehist"))
       (savehist-save-minibuffer-history t)
       (history-length 10000)  ; set to t for infinite history
       (history-delete-duplicates t)
       (savehist-additional-variables '(kill-ring
                                        search-ring
                                        regexp-search-ring
                                        shell-command-history))
       :config
       (savehist-mode +1))
   #+END_SRC

   Emacs can also save a list of your recently-edited files using the built-in
   [[https://www.emacswiki.org/emacs/RecentFiles][recentf-mode]] There are better tools for jumping between large numbers of files, which
   I set up later, but this is good to have around, especially for loose files.

   #+BEGIN_SRC emacs-lisp
     (use-package recentf
       :custom
       (recentf-max-saved-items 100)
       :config
       (recentf-mode +1))
   #+END_SRC

   Last but not least, the built-in [[https://www.emacswiki.org/emacs/SavePlace][save-place-mode]] will remember where the cursor was
   in a file when it was closed, and put the cursor back there when it's reopened.

   #+BEGIN_SRC emacs-lisp
     (use-package saveplace
       :config
       (save-place-mode +1))
   #+END_SRC

** Buffer Management

   By default, if two buffers point to different files with the same filename, Emacs
   numbers them. The built-in [[https://www.emacswiki.org/emacs/uniquify][uniquify]] library changes this behaviour to use the folder
   name instead.

   #+BEGIN_SRC emacs-lisp
     (use-package uniquify
       :straight nil
       :custom
       (uniquify-buffer-name-style 'forward))
   #+END_SRC

   The built-in [[https://www.emacswiki.org/emacs/IbufferMode][ibuffer-mode]] provides an improved interface for buffer management. All
   that's needed to set it up is to bind it to a key.

   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "C-x C-b") 'ibuffer)
   #+END_SRC

   I want my buffers to be set up for UTF-8 with UNIX line endings unless otherwise
   specified, even on Windows.

   #+BEGIN_SRC emacs-lisp
     (set-language-environment "UTF-8")
     (setq-default buffer-file-coding-system 'utf-8-unix)
   #+END_SRC

   When the file a buffer is monitoring is changed outside Emacs, it's helpful to have
   the buffer updated to match the file if the buffer hasn't been modified. The built-in
   [[https://www.emacswiki.org/emacs/AutoRevertMode][auto-revert-mode]] provides this feature.

   #+BEGIN_SRC emacs-lisp
     (global-auto-revert-mode +1)
   #+END_SRC

** Sparse GUI

   By default, Emacs provides a set of conventional UI elements. I like to turn most of
   these off, since there are alternatives that I'm more used to and take up less screen
   space. In spun-off configurations, I turn all of these back on. These also go into
   the =early-init.el= file, so that Emacs doesn't spend time loading those elements and
   then unloading them again.

   I prefer Emacs to go straight to an empty =*scratch*= when it loads, with no startup
   message.

   #+BEGIN_SRC emacs-lisp :tangle early-init.el
     (setq inhibit-startup-message t)
     (setq initial-scratch-message "hello, world!")
   #+END_SRC

   The menu bar can be useful for rarely-used commands to which one doesn't remember the
   keybindings. I generally prefer to use =M-x= to search for them by name, rather than
   hunting through the menu bar. However, on macOS, a menu bar gets drawn anyway, so we
   might as well leave it enabled.

   #+BEGIN_SRC emacs-lisp :tangle early-init.el
     (unless *my/is-macos*
       (menu-bar-mode -1))
   #+END_SRC

   The toolbar is geared towards frequently-used commands, and outlives its usefulness
   once you learn the keybindings.

   #+BEGIN_SRC emacs-lisp :tangle early-init.el
     (when (fboundp 'tool-bar-mode)
       (tool-bar-mode -1))
   #+END_SRC

   Word-wrapping is nicer than horizontal scrollbars, and there are smaller vertical
   position indicators available than vertical scrollbars.

   #+BEGIN_SRC emacs-lisp :tangle early-init.el
     (when (fboundp 'scroll-bar-mode)
       (scroll-bar-mode -1))
     (when (fboundp 'horizontal-scroll-bar-mode)
       (horizontal-scroll-bar-mode -1))
   #+END_SRC

   If you like line numbers, change this to =+1= instead of =-1=.

   #+BEGIN_SRC emacs-lisp
     (global-display-line-numbers-mode -1)
   #+END_SRC

   I find a blinking cursor distracting, but many people are used to it or need it in
   order to locate the cursor. Again, change to =+1= from =-1= to re-enable the cursor.

   #+BEGIN_SRC emacs-lisp
     (blink-cursor-mode -1)
   #+END_SRC

   See [[https://www.emacswiki.org/emacs/AlarmBell][Alarm Bell]] on the Emacs Wiki for options related to the bell. I currently prefer
   a simple flashing bell.

   #+BEGIN_SRC emacs-lisp
     (setq visible-bell t)
   #+END_SRC

   Emacs often asks yes-or-no questions, but some of the prompts don't accept bare y/n
   answers. Replacing the yes-or-no prompt with the y-or-n prompt fixes that if you want
   less typing in your life.

   #+BEGIN_SRC emacs-lisp
     (fset 'yes-or-no-p 'y-or-n-p)
   #+END_SRC

** Core Text Editing

   Conventional text editors allow you to replace text by selecting it and beginning to
   type. Emacs can do that too with the built-in [[https://www.emacswiki.org/emacs/DeleteSelectionMode][delete-selection-mode]].

   #+BEGIN_SRC emacs-lisp
     (delete-selection-mode +1)
   #+END_SRC

   When doing cut/paste (kill/yank) from inside Emacs, save the system clipboard to the
   kill ring so that we can get it back later. Also, when pasting with the mouse, insert
   at the point, rather than the actual click location.

   #+BEGIN_SRC emacs-lisp
     (setq save-interprogram-paste-before-kill t
           mouse-yank-at-point t)
   #+END_SRC

   Show the parenthesis matching the one the cursor is on.

   #+BEGIN_SRC emacs-lisp
     (show-paren-mode +1)
   #+END_SRC

   Use spaces instead of tabs for indentation by default. This can also be toggled
   per-mode or per-buffer. Also, require a final newline in files; per POSIX, it's
   required, though it usually doesn't matter. However, it /does/ matter for a few files
   (=crontab=), and Git doesn't seem to be a huge fan of files without trailing newlines.

   #+BEGIN_SRC emacs-lisp
     (setq-default indent-tabs-mode nil)
     (setq require-final-newline t)
   #+END_SRC

   Trailing whitespace tends to be a bit of a liability, since you can't see it easily.
   We would like buffers to highlight it by default, with the exception of the
   minibuffer, where it doesn't matter and tends to jank up the display from some tools.

   #+BEGIN_SRC emacs-lisp
     (setq-default show-trailing-whitespace t)

     (defun my/hide-trailing-whitespace ()
       (setq show-trailing-whitespace nil))

     (add-hook 'minibuffer-setup-hook
               'my/hide-trailing-whitespace)
   #+END_SRC

   Long lines are also a bit of a liability. Many people standardise on 80, but I
   usually settle on 88. Notably, the [[https://github.com/psf/black][Black autoformatter]] for Python does this as well.
   This setting can be changed per-mode and per-buffer.

   #+BEGIN_SRC emacs-lisp
     (setq-default fill-column 88)
     (setq-default auto-fill-function 'do-auto-fill)
   #+END_SRC

   Some files do have long lines in them, and I like to have those lines word-wrapped
   instead of scrolling off the side of the page.

   #+BEGIN_SRC emacs-lisp
     (setq-default truncate-lines nil)
     (global-visual-line-mode 1)
   #+END_SRC

   By default, Emacs binds =M-z= to =zap-to-char=, which deletes everything up to and
   including the specified character. An alternative that does not delete the specified
   character, =zap-up-to-char=, is included with Emacs. =better-defaults= rebinds this.

   #+BEGIN_SRC emacs-lisp
     (autoload 'zap-up-to-char "misc"
       "Kill up to, but not including ARGth occurrence of CHAR." t)
     (global-set-key (kbd "M-z") 'zap-up-to-char)
   #+END_SRC

   Input special characters by typing the TeX code for them.

   #+BEGIN_SRC emacs-lisp
     (setq default-input-method "TeX")
   #+END_SRC

   By default, Emacs searches for the ends of sentences by looking for a full stop and
   two spaces. I'm not in the habit of writing two spaces after a full stop, so I need
   it to look for one space, instead.

   #+BEGIN_SRC emacs-lisp
     (setq sentence-end-double-space nil)
   #+END_SRC

   Emacs provides a feature called [[https://www.emacswiki.org/emacs/HippieExpand][hippie-expand]] which tries to expand the word at the
   point into something more useful. It just needs to be bound to a keystroke.

   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "M-/") 'hippie-expand)
   #+END_SRC

** Emacs Server

   By starting an Emacs server, we can use /emacsclient/ to open files in our current
   Emacs session.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'after-init-hook #'server-start)
   #+END_SRC

** Apropos

   The [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Apropos.html][apropos system]] is used for finding relevant commands. This option expands the
   search to look for more stuff.

   #+BEGIN_SRC emacs-lisp
     (setq apropos-do-all t)
   #+END_SRC

** Ediff

   The built-in [[https://www.emacswiki.org/emacs/EdiffMode][ediff-mode]] provides an interface for diffing files and working with
   patches. By default it launches into a separate frame, but we can tell it to load in
   the current frame instead. Additionally, it's nicer if it displays windows
   side-by-side instead of stacked vertically.

   #+BEGIN_SRC emacs-lisp
     (setq ediff-window-setup-function 'ediff-setup-windows-plain
           ediff-split-window-function 'split-window-horizontally)
   #+END_SRC

** Mixed-DPI

   Because I often have a mixed-DPI setup, if I'm under X, I need to be able to rescale
   an entire Emacs frame at a time on the fly, so I also include keybindings for that.
   This can be hooked into for e.g. fixing treemacs icons.

   #+BEGIN_SRC emacs-lisp
     (defvar my/toggle-face-height-hook nil
       "Called when toggling the face height for mixed-DPI setups")

     (defun my/current-default-face-height ()
       (face-attribute 'default :height (selected-frame)))

     (defun my/toggle-face-height ()
       (interactive)

       (set-face-attribute 'default (selected-frame) :height
                           (if (> (my/current-default-face-height) 80) 60 100))
       (run-hooks 'my/toggle-face-height-hook))

     (global-set-key (kbd "C-x T s") 'my/toggle-face-height)
   #+END_SRC

* Visual Flair

  No point in setting up your editor so that it can make coffee and do your taxes if you
  can't stand looking at it. This section customizes the visual aspects of the Emacs
  experience, and is fairly modular.

** Libraries

   The [[https://github.com/magnars/dash.el][dash.el]] library provides extended functionality for dealing with lists in elisp.
   It's used in enough packages it'll end up in all but the most conservative configs
   anyway, so it might as well get included explicitly so that it can be used here.

   #+BEGIN_SRC emacs-lisp
     (use-package dash :config (dash-enable-font-lock))
   #+END_SRC

** Fonts

   I use [[https://github.com/belluzj/fantasque-sans][Fantasque Sans Mono]] for fixed-pitch text, and [[https://github.com/adobe-fonts/source-serif-pro][Source Serif Pro]] for
   variable-pitch text.

   #+BEGIN_SRC emacs-lisp :tangle early-init.el
     (add-to-list 'default-frame-alist
                  '(font . "Fantasque Sans Mono-10"))

     (set-face-attribute 'variable-pitch nil
                         :family "Source Serif Pro"
                         :height 1.25)
   #+END_SRC

   The height of 1.25 is chosen because otherwise it's too small on my screen, and the
   reciprocal is exactly 0.8, which is useful for fixed-width text which, for some
   reason, inherits its height from the =variable-pitch= face.

   Several modern coding fonts supply coding ligatures, which e.g. display >= as \ge.
   Emacs can use these, but needs to be told what characters to consider for ligatures.
   This is a bit of a pain, but one side-benefit is that ligatures that you dislike can
   be selectively disabled.

   The machinery for setting this up involves giving Emacs a set of regular expressions
   grouped by the first character of the ligature. The following function makes the
   appropriate arrangements automatically.

   #+BEGIN_SRC emacs-lisp
     (defun my/enable-compositions (ligatures)
       (-each (-group-by 'string-to-char ligatures)
         (-lambda ((char . comps))
           (set-char-table-range composition-function-table char
                                 `([,(regexp-opt comps) 0 font-shape-gstring])))))
   #+END_SRC

   All that remains is the pass in the strings that should become ligatures.

   #+BEGIN_SRC emacs-lisp
     (defvar my/compositions
       '("!=" "!=="
         "==" "===" "=>" "==>" "=>>" "=/=" "=<<"
         "->" "-->" "->>" "-<" "-<<"
         "<-" "<-<" "<<-" "<--" "<->" "<=<" "<<=" "<==" "<=>" "<~~" "<~" "<<<"
         "<<" "<=" "<~>" "<>" "<|||" "<||" "<|" "<|>" "<!--"
         ">->" ">=>" ">>=" ">>-" ">-" ">=" ">>" ">>>"
         "~~" "~>" "~~>"
         "|>" "||>" "|||>" "||"
         "::" "&&"
         "//" "/*" "/**/"
         "*/"))
     (my/enable-compositions my/compositions)
   #+END_SRC

   If the ligatures included in your font aren't enough for you, Emacs has
   [[https://emacsredux.com/blog/2014/08/25/a-peek-at-emacs-24-dot-4-prettify-symbols-mode/][prettify-symbols-mode]], which can visually replace strings with other strings, e.g.
   make the =lambda= elisp keyword display as =\lambda=. It can be turned on per-buffer,
   per-mode, or globally. I personally find it disruptive when enabled globally, but I
   may yet revisit it.

   #+BEGIN_SRC emacs-lisp
     (global-prettify-symbols-mode -1)
   #+END_SRC


** Color Scheme

   I personally like [[https://github.com/morhetz/gruvbox][gruvbox]] ([[https://github.com/greduan/emacs-theme-gruvbox][Emacs version]]), which provides both dark and light versions
   in a variety of contrast levels, and theming information for a variety of common
   extensions.

   #+BEGIN_SRC emacs-lisp :tangle early-init.el
     (use-package gruvbox-theme
       :demand t
       :config
       (setq my/light-theme 'gruvbox-light-medium)
       (setq my/dark-theme 'gruvbox-dark-soft)
       (setq my/initial-theme my/dark-theme)
       (load-theme my/initial-theme t))
   #+END_SRC

   For eye-comfort, it's worth making it easy to toggle between dark and light versions
   depending on the environment.

   #+BEGIN_SRC emacs-lisp
     (defun my/toggle-theme ()
       (interactive)

       (let ((is-dark (seq-contains-p custom-enabled-themes my/dark-theme)))
         (-each custom-enabled-themes 'disable-theme)
         (load-theme (if is-dark my/light-theme my/dark-theme) t)))

     (global-set-key (kbd "C-x t t") 'my/toggle-theme)
   #+END_SRC

** Icons

   [[https://github.com/domtronn/all-the-icons.el][All The Icons]] provides a set of icon-font based icons which can be used by several
   other packages. You need to run =M-x all-the-icons-install-fonts= before it will work.

   #+BEGIN_SRC emacs-lisp
     (use-package all-the-icons)
   #+END_SRC

** Mode Line

   The default Emacs modeline is pretty plain. I'm now using [[https://github.com/seagle0128/doom-modeline][doom-modeline]]. I've also
   tried out [[https://github.com/TheBB/spaceline][Spaceline]] and [[https://github.com/milkypostman/powerline][Powerline]]; they're fine, I just found this to be easier to
   work with.

   #+BEGIN_SRC emacs-lisp
     (use-package doom-modeline
       :custom
       (doom-modeline-major-mode-icon nil)
       (doom-modeline-height 40)
       (doom-modeline-project-detection 'projectile)
       (doom-modeline-minor-modes t)
       (doom-modeline-checker-simple-format nil)
       (doom-modeline-gnus nil)
       (doom-modeline-irc nil)
       :config
       (progn
         (doom-modeline-mode +1)
         (column-number-mode +1)))
   #+END_SRC

   Once a few minor modes are enabled, the modeline can get cluttered. The [[https://www.emacswiki.org/emacs/DelightedModes][delight]]
   package can help with this, by abbreviating or eliding mode names. =use-package=
   integrates with it as well. Some of the modes enabled in the [[Prelude]] section can
   benefit from this.

   #+BEGIN_SRC emacs-lisp
     (use-package delight)
     (use-package emacs
       :delight
       (auto-fill-function " $")
       (visual-line-mode))
   #+END_SRC

* Core Enhancements

  This is, effectively, part 2 of the [[Prelude]] section. The difference is that while the
  Prelude only brings in a package if it's absolutely essential, this section brings in
  packages which do at least one of two things:

  + Improve or replace built-in Emacs features in a way that's broadly useful.
  + Add features that are useful in practically every context.

  The packages in this section either show up in many Emacs configs, or are part of a
  class of packages one of which shows up in many Emacs configs.

** Keybindings

   The [[https://github.com/abo-abo/hydra][Hydra]] library provides tools for constructing groups of keybindings that require
   fewer keypresses by allowing a prefix to be implied if the previous keybinding was
   part of the same group.

   #+BEGIN_SRC emacs-lisp
     (use-package hydra)
   #+END_SRC

   May Emacs keybindings require a sequence of keystrokes. Which keys do what in which
   mode can be hard to remember; this provides a popup that shows [[https://github.com/justbur/emacs-which-key][which-key]] you might
   need next.

   #+BEGIN_SRC emacs-lisp
     (use-package which-key
       :delight which-key-mode
       :config (which-key-mode +1))
   #+END_SRC

** Text Completion

   Emacs features completion abilities, but [[https://company-mode.github.io/][company-mode]] expands those into a framework
   that other modes can build on.

   #+BEGIN_SRC emacs-lisp
     (use-package company
       :demand t
       :delight company-mode
       :hook (after-init . global-company-mode))
   #+END_SRC

   Less dramatically, [[https://github.com/Fuco1/smartparens][Smartparens]] helps insert paired characters for you. This config
   uses the strict mode, which tries to help you out when deleting text would cause
   delimiters to become unbalanced. It's enabled automatically for programming modes.

   #+BEGIN_SRC emacs-lisp
     (use-package smartparens
       :delight (smartparens-mode " ()")
       :hook (prog-mode . smartparens-strict-mode)
       :config
       (require 'smartparens-config))
   #+END_SRC

   To go with that, [[https://github.com/Fanael/rainbow-delimiters][rainbow-delimiters]] helps make it easy to see what's going on with
   those parentheses.

   #+BEGIN_SRC emacs-lisp
     (use-package rainbow-delimiters
       :hook (prog-mode . rainbow-delimiters-mode))
   #+END_SRC

** Minibuffer Completion

   Emacs has minibuffer completion built-in in the form of [[https://www.emacswiki.org/emacs/InteractivelyDoThings][ido-mode]]. However, there are
   two more advanced completion frameworks available: [[https://github.com/abo-abo/swiper][Ivy]] and [[https://github.com/emacs-helm/helm][Helm]]. Both have wide
   support, but at time of writing, the Helm maintainer [[https://github.com/emacs-helm/helm/issues/2386][had just halted development]]. I
   ended up switching to Ivy, which I rather like so far.

   #+BEGIN_SRC emacs-lisp
     (use-package ivy
       :demand t
       :delight ivy-mode
       :bind (("C-c C-r" . ivy-resume)
              ("C-x B" . ivy-switch-buffer-other-window))
       :custom
       (ivy-count-format "(%d/%d) ")
       (ivy-use-virtual-buffers t)
       (ivy-virtual-abbreviate 'full)
       :config (ivy-mode +1))
   #+END_SRC

   Ivy pairs well with Counsel, from the same repository, which integrates Ivy with a
   variety of built-in Emacs features.

   #+BEGIN_SRC emacs-lisp
     (use-package counsel
       :after ivy
       :delight counsel-mode
       :config (counsel-mode +1))
   #+END_SRC

   In order to display more information in Ivy minibuffers, [[https://github.com/Yevgnen/ivy-rich][ivy-rich]] adds the concept of
   transformers, and defines some useful default ones, which can display extra
   information (such a docstrings) inside Ivy menus.

   #+BEGIN_SRC emacs-lisp
     (use-package ivy-rich
       :after (ivy counsel all-the-icons-ivy-rich)
       :custom
       (ivy-rich-path-style 'abbrev)
       :config
       (setcdr (assq t ivy-format-functions-alist) #'ivy-format-function-line)
       (ivy-rich-mode +1))
   #+END_SRC

   For example, we can have icons in there.

   #+BEGIN_SRC emacs-lisp
     (use-package all-the-icons-ivy-rich
       :after counsel-projectile
       :config (all-the-icons-ivy-rich-mode +1))
   #+END_SRC

** Searching

   Expanding on the Ivy configuration above, Swiper, again part of the same project,
   provides a nifty search interface in the minibuffer.

   #+BEGIN_SRC emacs-lisp
     (use-package swiper
       :after ivy
       :bind (("C-s" . swiper)))
   #+END_SRC

   Additionally, I like having TODO/FIXME/etc. comments highlighted with a dedicated
   search feature. [[https://github.com/tarsius/hl-todo][hl-todo]] provides this, and we can give it a nice Hydra map.

   #+BEGIN_SRC emacs-lisp
     (use-package hl-todo
       :demand t
       :config
       (progn
         (defun my/hl-todo-swiper ()
           "Search for TODOs in Swiper"
           (interactive)
           (swiper (substring (hl-todo--regexp) 2 -2)))

         (defhydra hydra-hl-todo (hl-todo-mode-map "C-c")
           "Search TODOs"
           ("N" hl-todo-previous "previous")
           ("n" hl-todo-next "next")
           ("s" my/hl-todo-swiper "swiper" :exit t)
           ("o" hl-todo-occur "occur" :exit t)
           ("i" hl-todo-insert "insert" :exit t))
         (global-hl-todo-mode +1)))
   #+END_SRC

** Syntax Checking

   [[https://www.flycheck.org][Flycheck]] Is a replacement for the built-in Flymake. Several language-specific modes
   can be configured to take advantage of it.

   #+BEGIN_SRC emacs-lisp
     (use-package flycheck
       :demand t
       :delight flycheck-mode  ; doom-modeline has a dedicated indicator for this
       :hook (after-init . global-flycheck-mode))
   #+END_SRC

** Projects

   Emacs doesn't really have a concept of projects, i.e. groups of related files, as
   such. It's useful, though, and [[https://github.com/bbatsov/projectile][Projectile]] provides a framework and features for
   working with this.

   #+BEGIN_SRC emacs-lisp
     (use-package projectile
       :delight (projectile-mode
                 (:eval (format " p:%s" (projectile-project-type))))
       :bind-keymap ("C-c p" . projectile-command-map)
       :custom
       (projectile-completion-system 'ivy)
       :config (projectile-discover-projects-in-search-path))
   #+END_SRC

   It natively supports Ivy, but [[https://github.com/ericdanan/counsel-projectile][counsel-projectile]] takes the integration further.

   #+BEGIN_SRC emacs-lisp
     (use-package counsel-projectile
       :config (counsel-projectile-mode +1))  ; also enables projectile-mode
   #+END_SRC

** Undo/Redo

   Tree-style undo/redo via [[http://www.dr-qubit.org/undo-tree.html][undo-tree]] (also [[https://www.emacswiki.org/emacs/UndoTree][wiki]]).

   #+BEGIN_SRC emacs-lisp
     (use-package undo-tree
       :delight undo-tree-mode
       :custom
       (undo-tree-visualizer-timestamps t)
       (undo-tree-visualizer-diff t)
       :config (global-undo-tree-mode +1))
   #+END_SRC

** Window Management

   I'm currently using [[https://github.com/abo-abo/ace-window][ace-window]] for navigating windows, since Treemacs depends on it
   anyway (see [[File Explorer]]). Another option is [[https://github.com/deb0ch/emacs-winum][winum]].

   #+BEGIN_SRC emacs-lisp
     (use-package ace-window
       :demand t
       :custom
       (aw-display-mode-overlay nil)
       (aw-dispatch-always t)
       (aw-background nil)
       :bind ("M-o" . ace-window)
       :config (ace-window-display-mode +1))
   #+END_SRC

** File Explorer

   I find it helpful to have a tree-style file explorer in a sidebar. [[https://github.com/Alexander-Miller/treemacs][Treemacs]] provides
   this feature. I have it bound into the =ace-window= keymap.

   #+BEGIN_SRC emacs-lisp
     (use-package treemacs
       :hook (after-init . treemacs-select-window)  ; open on start
       :config
       (progn
         (add-to-list 'aw-dispatch-alist '(?t treemacs-select-window))
         (add-to-list 'aw-dispatch-alist '(?T treemacs))
         (treemacs-git-mode 'deferred)
         (treemacs-filewatch-mode 1)
         (define-key treemacs-mode-map [mouse-1]
           #'treemacs-single-click-expand-action)))
   #+END_SRC

   It also integrates with =projectile-mode= (see [[Projects]]).

   #+BEGIN_SRC emacs-lisp
     (use-package treemacs-projectile
       :after (treemacs projectile))
   #+END_SRC

   It also needs to be hooked into the [[Mixed-DPI]] helper, otherwise the icon sizes end up
   wrong.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'my/toggle-face-height-hook
               #'(lambda ()
                   (treemacs-resize-icons
                    (if (> (my/current-default-face-height) 80) 22 11))))
   #+END_SRC

   If All The Icons was installed, Treemacs can use them.

   #+BEGIN_SRC emacs-lisp
     (use-package treemacs-all-the-icons
       :requires all-the-icons)
   #+END_SRC

** Git

   [[https://magit.vc/][Magit]] is a Git porcelain, and can be considered one of the killer apps for Emacs.
   Never leave home without it. It's good enough that, as a longtime Mercurial fan, I
   stoppped using it for personal projects because it didn't work with Magit.

   #+BEGIN_SRC emacs-lisp
     (use-package magit
       :bind ("C-x g" . magit-status))
   #+END_SRC

   Treemacs provides a Magit integration so that it knows when to redo highlighting for
   which files are staged/unstaged.

   #+BEGIN_SRC emacs-lisp
     (use-package treemacs-magit
       :after (treemacs magit))
   #+END_SRC

   It's also handy to show which lines have changed in the fringe. [[https://github.com/emacsorphanage/git-gutter-fringe][git-gutter-fringe]]
   provides that.

   #+BEGIN_SRC emacs-lisp
     (use-package git-gutter-fringe
       :delight git-gutter-mode
       :config (global-git-gutter-mode +1))
   #+END_SRC

* Evil

  As a VIM refugee with modal editing burned into my fingers, I really like [[https://github.com/emacs-evil/evil][Evil]]. It
  emulates /vi/ inside of Emacs, and it does it really well. If you are not used to VIM,
  you do not want anything to do with this section.

  #+BEGIN_SRC emacs-lisp
    (use-package evil
      :config
      (evil-mode +1))
  #+END_SRC

  At this time, I don't make any particular effort to rebind things to /vi/-style
  keybindings; I mostly care about basic editing. However, some modes don't work
  properly without being told about Evil, so the rest of this section does just that.
  It's organized by package, rather than feature.

** Magit

   Evil provides an [[https://github.com/emacs-evil/evil-magit][Evil-Magit]] integration.

   #+BEGIN_SRC emacs-lisp
     (use-package evil-magit
       :after (evil magit))
   #+END_SRC

** Origami

   [[https://github.com/gregsexton/origami.el][origami.el]] is a code-folding minor mode. I don't actually have it set up above, since
   I mainly found it as a way to implement something lime VIM's source code folding.

   #+BEGIN_SRC emacs-lisp
     (use-package origami
       :after evil
       :hook (magit-mode . (lambda () (origami-mode -1)))  ; don't enable this in magit
       :config
       (progn
         (evil-define-key 'normal origami-mode-map "zo" 'origami-open-node)
         (evil-define-key 'normal origami-mode-map "zO" 'origami-open-node-recursively)
         (evil-define-key 'normal origami-mode-map "zc" 'origami-close-node)
         (evil-define-key 'normal origami-mode-map "zC" 'origami-close-node-recursively)
         (evil-define-key 'normal origami-mode-map "za" 'origami-forward-toggle-node)
         (evil-define-key 'normal origami-mode-map "zA" 'origami-recursively-toggle-node)
         (evil-define-key 'normal origami-mode-map "zv" 'origami-show-node)
         (evil-define-key 'normal origami-mode-map "zx" 'origami-reset)
         (evil-define-key 'normal origami-mode-map "zm" 'origami-close-all-nodes)
         (evil-define-key 'normal origami-mode-map "zr" 'origami-open-all-nodes)
         (global-origami-mode +1)))
   #+END_SRC

** TODO Smartparens

   Add the fancy paren handling into Evil with [[https://github.com/luxbock/evil-cleverparens][evil-cleverparens]]. (See [[Text Completion]])

   #+BEGIN_SRC emacs-lisp
     (use-package evil-cleverparens
       :delight evil-cleverparens-mode
       :hook (smartparens-enabled . evil-cleverparens-mode))
   #+END_SRC

** Spaceline

   #+BEGIN_SRC emacs-lisp
     (setq spaceline-highlight-face-func 'spaceline-highlight-face-evil-state)
   #+END_SRC

** Swiper

   The only integration this really needs is rebinding the search keys. (See [[Searching]])

   #+BEGIN_SRC emacs-lisp
     (define-key evil-normal-state-map (kbd "/") 'swiper)
     (define-key evil-normal-state-map (kbd "?") 'swiper-backward)
     (define-key evil-normal-state-map (kbd "*") 'swiper-thing-at-point)
   #+END_SRC

** Treemacs

   Treemacs provides an integration for Evil.

   #+BEGIN_SRC emacs-lisp
     (use-package treemacs-evil
       :after (treemacs evil))
   #+END_SRC

* Languages
** Common

   Many languages now have Language Server Protocol backends for them. For Emacs,
   [[https://github.com/emacs-lsp/lsp-mode/][lsp-mode]] allows us to take advantage of these. The language-specific configurations
   are grouped under the relevant headers, including the hooks.

   #+BEGIN_SRC emacs-lisp
     (use-package lsp-mode
       :hook ((lsp-mode . lsp-enable-which-key-integration))
       :custom
       (lsp-keymap-prefix "C-l")
       :commands lsp)

     (use-package lsp-ui
       :commands lsp-ui-mode)

     (use-package lsp-ivy  ; ivy integration
       :commands lsp-ivy-workspace-symbol)

     (use-package lsp-treemacs  ; treemacs integration
       :commands lsp-treemacs-errors-list)
   #+END_SRC

   [[https://www.emacswiki.org/emacs/ElDoc][El Doc]] gets pulled in a lot (LSP uses it), and it's generally obvious that it's
   present because you start getting lots of little popups, so it doesn't need a lighter.

   #+BEGIN_SRC emacs-lisp
     (delight 'eldoc-mode nil t)
   #+END_SRC

** C/C++

   #+BEGIN_SRC emacs-lisp
     (use-package irony
       :hook (((c++-mode c-mode objc-mode) . irony-mode)
              (irony-mode . irony-cdb-autosetup-compile-options))
       :init
       (progn
         (when (string= "windows-nt" system-type)
           (setq exec-path (append exec-path '("~/scoop/apps/llvm/10.0.0/bin"))))
         (when (boundp 'w32-pipe-read-delay)
           (setq w32-pipe-read-delay 0))
         (when (boundp 'w32-pipe-buffer-size)
           (setq irony-server-w32-pipe-buffer-size (* 64 1024)))))

     (use-package cmake-ide
       :demand t
       :config (cmake-ide-setup))
   #+END_SRC

** CUDA

   #+BEGIN_SRC emacs-lisp
     (use-package cuda-mode
       :mode (("\\.cu\\'" . cuda-mode)
              ("\\.cuh\\'" . cuda-mode)))
   #+END_SRC

** fish shell

   #+BEGIN_SRC emacs-lisp
     (use-package fish-mode
       :mode (("\\.fish\\'" . fish-mode)))
   #+END_SRC

** Go

   #+BEGIN_SRC emacs-lisp
     ;; (use-package company-go)
     (use-package go-mode
       :mode ("\\.go\\'". go-mode)
       :init
       (progn
         (defun my/go-mode-locals ()
           ;; (set (make-local-variable 'company-backends) '(company-go))
           ;; (company-mode 1)
           (setq tab-width 3))
         (add-hook 'go-mode-hook #'my/go-mode-locals)
         (add-hook 'go-mode-hook #'flycheck-mode)
         (add-hook 'before-save-hook #'gofmt-before-save)))
   #+END_SRC

** Lua

   #+BEGIN_SRC emacs-lisp
     (use-package lua-mode
       :commands (lua-mode)
       :mode ("\\.lua\\'" . lua-mode))
   #+END_SRC

** Markdown

   #+BEGIN_SRC emacs-lisp
     (use-package markdown-mode
       :commands (markdown-mode gfm-mode)
       :mode (("README\\.md\\'" . gfm-mode)
              ("\\.md\\'" . markdown-mode)
              ("\\.markdown\\'" . markdown-mode))
       :init (setq markdown-command "multimarkdown"))
   #+END_SRC

** MATLAB

   Normally, =.m= files are treated as Objective-C files. I don't really do any ObjC, so
   they're going to be treated as MATLAB files instead.

   #+BEGIN_SRC emacs-lisp
     (use-package matlab-mode
       :mode "\\.m\\'"
       :init
       (progn
         (setq matlab-indent-function t)  ; TODO figure out what this does
         (setq matlab-shell-command "/usr/local/bin/matlab")))
   #+END_SRC

** Org-Mode

   #+BEGIN_SRC emacs-lisp
     (use-package org
       :mode ("\\.org\\'" . org-mode)
       :bind (("C-c l" . org-store-link)
              ("C-c a" . org-agenda)
              ("C-c c" . org-capture))
       :custom
       (org-log-done t)
       (org-hide-emphasis-markers t))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package htmlize
       :commands (htmlize-buffer
                  htmlize-region
                  htmlize-file
                  htmlize-many-files
                  htmlize-many-files-dired))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (delight 'buffer-face-mode nil t)
     (use-package org-variable-pitch
       :delight
       (org-variable-pitch-minor-mode)
       :hook (org-mode . org-variable-pitch--enable)
       :config
       (set-face-attribute 'org-variable-pitch-fixed-face nil
                           :family (org-variable-pitch--get-fixed-font)
                           :height 0.8)
       (set-face-attribute 'org-level-1 nil :height (+ 1.0 (expt 0.5 0)))
       (set-face-attribute 'org-level-2 nil :height (+ 1.0 (expt 0.5 1)))
       (set-face-attribute 'org-level-3 nil :height (+ 1.0 (expt 0.5 2)))
       (set-face-attribute 'org-level-4 nil :height (+ 1.0 (expt 0.5 3)))
       (set-face-attribute 'org-level-5 nil :height (+ 1.0 (expt 0.5 4)))
       (set-face-attribute 'org-level-6 nil :height (+ 1.0 (expt 0.5 5)))
       (set-face-attribute 'org-level-7 nil :height (+ 1.0 (expt 0.5 6)))
       (set-face-attribute 'org-level-8 nil :height (+ 1.0 (expt 0.5 7))))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package org-d20
       :commands org-d20-mode)
   #+END_SRC

** TODO Ocaml

   #+NAME: packages/ocaml
   | Package        | Description     |
   |----------------+-----------------|
   | ggtags         |                 |

   #+BEGIN_SRC emacs-lisp
     ;; (defun my/ocaml/init-opam ()
     ;;   (if (executable-find "opam")
     ;;       (let ((share (string-trim-right
     ;;                     (with-output-to-string
     ;;                       (with-current-buffer
     ;;                           standard-output
     ;;                         (process-file
     ;;                          shell-file-name nil '(t nil) nil shell-command-switch
     ;;                          "opam config var share"))))))
     ;;         (cond ((string= "" share)
     ;;                (message "warning: `%s' output empty string." "opam config var share"))
     ;;               ((not (file-directory-p share))
     ;;                (message "%s" "warning: opam share directory does not exist."))
     ;;               (t (setq opam-share share
     ;;                        opam-load-path (concat share "/emacs/site-lisp"))
     ;;                  (add-to-list 'load-path opam-load-path))))
     ;;     (unless (executable-find "ocamlmerlin")
     ;;       (message "warning: cannot find `%s' or `%s' executable." "opam" "merlin"))))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package tuareg
       :mode (("\\.ml[ily]?$" . tuareg-mode)
              ("\\.topml$" . tuareg-mode))
       :init
       (progn
         ;; (my/ocaml/init-opam)
         (add-hook 'tuareg-mode-hook 'company-mode)
         (add-hook 'tuareg-mode-hook 'flycheck-mode)
         (dolist (ext '(".cmo" ".cmx" ".cma" ".cmxa" ".cmi" ".cmxs" ".cmt"
                        ".cmti" ".annot"))
           (add-to-list 'completion-ignored-extensions ext))))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package merlin
       :delight (merlin-mode " ⚗")
       :hook (tuareg-mode . merlin-mode)
       :init
       (progn
         (add-to-list 'company-backends 'merlin-company-backend)))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package ocp-indent
       :hook (tuareg-mode . ocp-indent-caml-mode-setup))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (with-eval-after-load 'smartparens
       (sp-local-pair 'tuareg-mode "'" nil :actions nil)
       (sp-local-pair 'tuareg-mode "`" nil :actions nil))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package utop
       :delight (utop-minor-mode " ū")
       :hook (tuareg-mode . utop-minor-mode)
       :config
       (progn
         (if (executable-find "opam")
             (setq utop-command "opam config exec -- utop -emacs")
           (message "warning: cannot find `opam' executable."))))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package flycheck-ocaml
       :after (flycheck merlin)
       :config
       (progn
         (setq merlin-error-after-save nil)
         (flycheck-ocaml-setup)))
   #+END_SRC

   Register a projectile project type for Dune.

   #+BEGIN_SRC emacs-lisp
     (use-package dune
       :mode ("\\(?:\\`\\|/\\)dune\\(?:\\.inc\\)?\\'" . dune-mode)
       :commands (dune-promote dune-runtest-and-promote))

     (with-eval-after-load 'projectile
       (projectile-register-project-type
        'dune '("dune-project")
        :compile "dune build"
        :test "dune runtest"))
   #+END_SRC

** Python

   Emacs includes a solid built-in =python-mode=, but since we have LSP support, we can
   extend that a bit. (There are many other Python modes, such as Elpy, but I jump
   between languages enough that I'm beginning to value consistency a bit.)

   #+BEGIN_SRC emacs-lisp
     (use-package lsp-python-ms
       :defer t
       :custom
       (lsp-python-ms-auto-install-server t)
       (lsp-python-ms-executable (executable-find "Microsoft.Python.LanguageServer"))
       :hook (python-mode . (lambda ()
                              (require 'lsp-python-ms)
                              (lsp))))
   #+END_SRC

   Automatically format Python code on save using the Black formatter.

   #+BEGIN_SRC emacs-lisp
     (use-package blacken
       :delight blacken-mode
       :hook (python-mode . blacken-mode))
   #+END_SRC

** Rust

   #+BEGIN_SRC emacs-lisp
     (use-package rustic
       :mode ("\\.rs\\'" . rustic-mode))
   #+END_SRC

** TODO TeX

   [[https://github.com/raxod502/straight.el/issues/240][AUCTeX is a pain in the ass to install.]] Need to figure out how to delay-load this.

   #+BEGIN_SRC emacs-lisp
     (straight-use-package 'auctex)
     (setq TeX-parse-self t) ; Enable parse on load.
     (setq TeX-auto-save t) ; Enable parse on save.
     (setq TeX-view-program-list
           '(("SumatraPDF"
              ("SumatraPDF.exe -reuse-instance"
               (mode-io-correlate " -forward-search \"%b\" %n")
               " %o")
              "SumatraPDF")))
     (setq TeX-view-program-selection '((output-pdf "SumatraPDF")))
     (setq TeX-source-correlate-mode t)
     (setq TeX-source-correlate-method 'synctex)
   #+END_SRC

** Zig

   #+BEGIN_SRC emacs-lisp
     (use-package zig-mode
       :commands (zig-mode)
       :hook (zig-mode . lsp)
       :mode ("\\.zig\\'" . zig-mode))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (with-eval-after-load 'projectile
       (projectile-register-project-type
        'zig '("build.zig")
        :compile "zig build"
        :test "zig build"))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (with-eval-after-load "lsp-mode"
       (add-to-list 'lsp-language-id-configuration '(zig-mode . "zig"))
       (lsp-register-client
        (make-lsp-client
         :new-connection (lsp-stdio-connection
                          (expand-file-name "~/Source/zls/zig-cache/bin/zls.exe"))
         :major-modes '(zig-mode)
         :server-id 'zls)))
   #+END_SRC

* Miscellanea

** TRAMP

   #+BEGIN_SRC emacs-lisp
     (setq-default explicit-shell-file-name "/bin/bash")
   #+END_SRC

* Machine-Specific Settings

  Machine-specific settings are loaded from separate files, distinguished by the
  machine's hostname, so that they can be checked in side-by-side.

  #+BEGIN_SRC emacs-lisp
    (defun my/load-local-init ()
      (interactive)
      (let* ((system-type-fs (subst-char-in-string ?/ ?- (symbol-name system-type)))
             (local-init (format "local-%s-%s" (system-name) system-type-fs))
             (local-init-path (expand-file-name local-init user-emacs-directory)))
        (condition-case nil
            (progn
              (load local-init-path)
              (message "%s init complete" (system-name)))
          (error (message "No local into file \"%s\"" local-init-path)))))

    (add-hook 'after-init-hook 'my/load-local-init)
  #+END_SRC

  Note that the machine-specific settings are loaded as the last thing, after the rest
  of the init file has been processed. I mostly use these for setting up installation
  paths for things which can vary between machines, e.g. Python.

** Ancalagon

   #+BEGIN_SRC emacs-lisp :tangle local-ancalagon-gnu-linux.el
     ;;; local-ancalagon-gnu-linux.el --- local init for ancalagon (GNU/Linux)

     ;;; Commentary:
     ;; THIS IS A GENERATED FILE; changes should be made to README.org

     ;;; Code:

     (setq projectile-project-search-path '("~/src"))
     (setq treemacs-python-executable (executable-find "python3"))

     ;;; local-ancalagon-gnu-linux.el ends here
   #+END_SRC

** Galatine

   #+BEGIN_SRC emacs-lisp :tangle local-galatine-windows-nt.el
     ;;; local-galatine-windows-nt.el --- local init for galatine (Windows)

     ;;; Commentary:
     ;; THIS IS A GENERATED FILE; changes should be made to README.org

     ;;; Code:

     (setq projectile-project-search-path '("~/Source"))
     (setq treemacs-python-executable (executable-find "python"))
     (setq flycheck-python-pycompile-executable (executable-find "python"))

     ;;; local-galatine-windows-nt.el ends here
   #+END_SRC

** Milliways

   #+BEGIN_SRC emacs-lisp :tangle local-milliways-gnu-linux.el
     ;;; local-milliways-gnu-linux.el --- local init for milliways (GNU/Linux)

     ;;; Commentary:
     ;; THIS IS A GENERATED FILE; changes should be made to README.org

     ;;; Code:

     (setq projectile-project-search-path '("~/src"))
     (setq treemacs-python-executable (executable-find "python3"))

     ;;; local-milliways-gnu-linux.el ends here
   #+END_SRC

* Coda

  #+BEGIN_SRC emacs-lisp :tangle early-init.el
    (message "early bird init complete")
    ;;; early-init.el ends here
  #+END_SRC

  #+BEGIN_SRC emacs-lisp
    (message "main init complete")
    ;;; init.el ends here
  #+END_SRC
